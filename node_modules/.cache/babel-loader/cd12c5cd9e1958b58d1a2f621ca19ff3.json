{"ast":null,"code":"import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _bindInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/bind\";\nimport _defineProperty from \"@babel/runtime-corejs3/helpers/esm/defineProperty\";\n\nvar _CALLBACKS;\n/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\n\n\nimport { uniqueId } from '../lang';\nimport { Logger } from '../logger/LoggerFactory';\nimport timer from './timer';\nimport thenable from '../promise/thenable'; // logger to be used on this module\n\nvar logger = new Logger('[TIME TRACKER]', {\n  showLevel: false\n}); // Map we will use for storing timers data\n\nvar timers = {}; // Tasks constants\n\nvar CONSTANTS = {\n  SDK_READY: 'Getting ready - Split SDK',\n  SDK_GET_TREATMENT: 'SDK - Get Treatment',\n  SDK_GET_TREATMENTS: 'SDK - Get Treatments',\n  SDK_GET_TREATMENT_WITH_CONFIG: 'SDK - Get Treatment with config',\n  SDK_GET_TREATMENTS_WITH_CONFIG: 'SDK - Get Treatments with config',\n  SPLITS_READY: 'Getting ready - Splits',\n  SEGMENTS_READY: 'Getting ready - Segments',\n  METRICS_PUSH: 'Pushing - Metrics',\n  IMPRESSIONS_PUSH: 'Pushing - Impressions',\n  EVENTS_PUSH: 'Pushing - Events',\n  MY_SEGMENTS_FETCH: 'Fetching - My Segments',\n  SEGMENTS_FETCH: 'Fetching - Segments',\n  SPLITS_FETCH: 'Fetching - Splits'\n}; // Tasks callbacks, if any\n\nvar CALLBACKS = (_CALLBACKS = {}, _defineProperty(_CALLBACKS, CONSTANTS.SDK_READY, {\n  collector: 'client',\n  method: 'ready'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT, {\n  collector: 'client',\n  method: 'getTreatment'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS, {\n  collector: 'client',\n  method: 'getTreatments'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT_WITH_CONFIG, {\n  collector: 'client',\n  method: 'getTreatmentWithConfig'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS_WITH_CONFIG, {\n  collector: 'client',\n  method: 'getTreatmentsWithConfig'\n}), _defineProperty(_CALLBACKS, CONSTANTS.MY_SEGMENTS_FETCH, {\n  collector: 'mySegments',\n  method: 'latency'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SEGMENTS_FETCH, {\n  collector: 'segmentChanges',\n  method: 'latency'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SPLITS_FETCH, {\n  collector: 'splitChanges',\n  method: 'latency'\n}), _CALLBACKS);\n/**\n * Generates the timer keys using the task name and a modifier, if any.\n * @param {string} task - The task name\n * @param {string} modifier - (optional) The modifier, if any.\n * @return {string} The generated timer key\n */\n\nvar generateTimerKey = function generateTimerKey(task, modifier) {\n  return typeof modifier === 'string' ? task + modifier : task;\n};\n/**\n * Given the collectors map, it returns the specific collector for a given task.\n *\n * @param {string} task - The task name\n * @param {Object} collectors - The collectors map\n */\n\n\nvar getCollectorForTask = function getCollectorForTask(task, collectors) {\n  var callbackData = CALLBACKS[task];\n  if (callbackData && collectors) return collectors[callbackData.collector];\n  return false;\n};\n/**\n * Given a collector and a task, returns the callback function that should be called when we stop the timer.\n *\n * @param {string} task - The task name\n * @param {Object} collector - The collector object for the task\n */\n\n\nvar getCallbackForTask = function getCallbackForTask(task, collector) {\n  var callbackData = CALLBACKS[task];\n  if (callbackData && collector) return collector[callbackData.method];\n  return false;\n};\n\nvar TrackerAPI = {\n  /**\n   * \"Private\" method, used to attach count/countException and stop callbacks to a promise.\n   *\n   * @param {Promise} promise - The promise we want to attach the callbacks.\n   * @param {string} task - The name of the task.\n   * @param {string} modifier - (optional) The modifier for the task, if any.\n   */\n  __attachToPromise: function __attachToPromise(promise, task, collector, modifier) {\n    var _this = this;\n\n    return promise.then(function (resp) {\n      _this.stop(task, modifier);\n\n      if (collector && collector.count) collector.count(resp.status);\n      return resp;\n    })[\"catch\"](function (err) {\n      _this.stop(task, modifier);\n\n      if (collector && collector.countException) collector.countException();\n      throw err;\n    });\n  },\n\n  /**\n   * Starts tracking the time for a given task. All tasks tracked are considered \"unique\" because\n   * there may be multiple SDK instances tracking a \"generic\" task, making any task non-generic.\n   *\n   * @param {string} task - The task we are starting.\n   * @param {Object} collectors - The collectors map.\n   * @param {Promise} promise - (optional) The promise we are tracking.\n   * @return {Function | Promise} The stop function for this specific task or the promise received with the callbacks registered.\n   */\n  start: function start(task, collectors, promise) {\n    var taskUniqueId = uniqueId();\n    var taskCollector = getCollectorForTask(task, collectors);\n    var result; // If we are registering a promise with this task, we should count the status and the exceptions as well\n    // as stopping the task when the promise resolves. Then return the promise\n\n    if (thenable(promise)) {\n      result = this.__attachToPromise(promise, task, taskCollector, taskUniqueId);\n    } else {\n      var _context; // If not, we return the stop function, as it will be stopped manually.\n\n\n      result = _bindInstanceProperty(_context = this.stop).call(_context, this, task, taskUniqueId);\n\n      if (CALLBACKS[task] && !taskCollector) {\n        var _context2; // and provide a way for a defered setup of the collector, if needed.\n\n\n        result.setCollectorForTask = _bindInstanceProperty(_context2 = this.setCollectorForTask).call(_context2, this, task, taskUniqueId);\n      }\n    } // We start the timer, with an uniqueId attached to it's name, and save tracking info for this task.\n\n\n    var trackingKey = generateTimerKey(task, taskUniqueId);\n    var cb = getCallbackForTask(task, taskCollector);\n    timers[trackingKey] = {\n      cb: cb,\n      timer: timer()\n    };\n    return result;\n  },\n\n  /**\n   * Setup the collector for a task that reports metrics.\n   *\n   * @param {string} task - The task name\n   * @param {string} taskUniqueId - The unique identifier for this task\n   * @param {Object} collectors - The collectors map.\n   */\n  setCollectorForTask: function setCollectorForTask(task, taskUniqueId, collectors) {\n    var taskCollector = getCollectorForTask(task, collectors);\n\n    if (taskCollector) {\n      var trackingKey = generateTimerKey(task, taskUniqueId);\n      timers[trackingKey].cb = getCallbackForTask(task, taskCollector);\n    }\n  },\n\n  /**\n   * Stops the tracking of a given task.\n   *\n   * @param {string} task - The task we are starting.\n   * @param {string} modifier - (optional) The modifier for that specific task.\n   */\n  stop: function stop(task, modifier) {\n    var timerName = generateTimerKey(task, modifier);\n    var timerData = timers[timerName];\n\n    if (timerData) {\n      var _context3; // Stop the timer and round result for readability.\n\n\n      var et = timerData.timer();\n      logger.debug(_concatInstanceProperty(_context3 = \"[\".concat(task, \"] took \")).call(_context3, et, \"ms to finish.\")); // Check if we have a tracker callback.\n\n      if (timerData.cb) {\n        // If we have a callback, we call it with the elapsed time of the task and then delete the reference.\n        timerData.cb(et);\n      } // Remove the task tracking reference.\n\n\n      delete timers[timerName];\n      return et;\n    }\n  },\n\n  /**\n   * The constants shortcut for the task names.\n   */\n  TaskNames: CONSTANTS\n}; // Our \"time tracker\" API\n\nexport default TrackerAPI;","map":{"version":3,"sources":["/Users/talianassi/Desktop/todolist/node_modules/@splitsoftware/splitio/es/utils/timeTracker/index.js"],"names":["_concatInstanceProperty","_bindInstanceProperty","_defineProperty","_CALLBACKS","uniqueId","Logger","timer","thenable","logger","showLevel","timers","CONSTANTS","SDK_READY","SDK_GET_TREATMENT","SDK_GET_TREATMENTS","SDK_GET_TREATMENT_WITH_CONFIG","SDK_GET_TREATMENTS_WITH_CONFIG","SPLITS_READY","SEGMENTS_READY","METRICS_PUSH","IMPRESSIONS_PUSH","EVENTS_PUSH","MY_SEGMENTS_FETCH","SEGMENTS_FETCH","SPLITS_FETCH","CALLBACKS","collector","method","generateTimerKey","task","modifier","getCollectorForTask","collectors","callbackData","getCallbackForTask","TrackerAPI","__attachToPromise","promise","_this","then","resp","stop","count","status","err","countException","start","taskUniqueId","taskCollector","result","_context","call","_context2","setCollectorForTask","trackingKey","cb","timerName","timerData","_context3","et","debug","concat","TaskNames"],"mappings":"AAAA,OAAOA,uBAAP,MAAoC,uDAApC;AACA,OAAOC,qBAAP,MAAkC,qDAAlC;AACA,OAAOC,eAAP,MAA4B,mDAA5B;;AAEA,IAAIC,UAAJ;AAEA;;;;;;;;;;;;;;;;;AAeA,SAASC,QAAT,QAAyB,SAAzB;AACA,SAASC,MAAT,QAAuB,yBAAvB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,QAAP,MAAqB,qBAArB,C,CAA4C;;AAE5C,IAAIC,MAAM,GAAG,IAAIH,MAAJ,CAAW,gBAAX,EAA6B;AACxCI,EAAAA,SAAS,EAAE;AAD6B,CAA7B,CAAb,C,CAEI;;AAEJ,IAAIC,MAAM,GAAG,EAAb,C,CAAiB;;AAEjB,IAAIC,SAAS,GAAG;AACdC,EAAAA,SAAS,EAAE,2BADG;AAEdC,EAAAA,iBAAiB,EAAE,qBAFL;AAGdC,EAAAA,kBAAkB,EAAE,sBAHN;AAIdC,EAAAA,6BAA6B,EAAE,iCAJjB;AAKdC,EAAAA,8BAA8B,EAAE,kCALlB;AAMdC,EAAAA,YAAY,EAAE,wBANA;AAOdC,EAAAA,cAAc,EAAE,0BAPF;AAQdC,EAAAA,YAAY,EAAE,mBARA;AASdC,EAAAA,gBAAgB,EAAE,uBATJ;AAUdC,EAAAA,WAAW,EAAE,kBAVC;AAWdC,EAAAA,iBAAiB,EAAE,wBAXL;AAYdC,EAAAA,cAAc,EAAE,qBAZF;AAadC,EAAAA,YAAY,EAAE;AAbA,CAAhB,C,CAcG;;AAEH,IAAIC,SAAS,IAAItB,UAAU,GAAG,EAAb,EAAiBD,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACC,SAAvB,EAAkC;AACjFc,EAAAA,SAAS,EAAE,QADsE;AAEjFC,EAAAA,MAAM,EAAE;AAFyE,CAAlC,CAAhC,EAGbzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACE,iBAAvB,EAA0C;AAC3Da,EAAAA,SAAS,EAAE,QADgD;AAE3DC,EAAAA,MAAM,EAAE;AAFmD,CAA1C,CAHF,EAMbzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACG,kBAAvB,EAA2C;AAC5DY,EAAAA,SAAS,EAAE,QADiD;AAE5DC,EAAAA,MAAM,EAAE;AAFoD,CAA3C,CANF,EASbzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACI,6BAAvB,EAAsD;AACvEW,EAAAA,SAAS,EAAE,QAD4D;AAEvEC,EAAAA,MAAM,EAAE;AAF+D,CAAtD,CATF,EAYbzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACK,8BAAvB,EAAuD;AACxEU,EAAAA,SAAS,EAAE,QAD6D;AAExEC,EAAAA,MAAM,EAAE;AAFgE,CAAvD,CAZF,EAebzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACW,iBAAvB,EAA0C;AAC3DI,EAAAA,SAAS,EAAE,YADgD;AAE3DC,EAAAA,MAAM,EAAE;AAFmD,CAA1C,CAfF,EAkBbzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACY,cAAvB,EAAuC;AACxDG,EAAAA,SAAS,EAAE,gBAD6C;AAExDC,EAAAA,MAAM,EAAE;AAFgD,CAAvC,CAlBF,EAqBbzB,eAAe,CAACC,UAAD,EAAaQ,SAAS,CAACa,YAAvB,EAAqC;AACtDE,EAAAA,SAAS,EAAE,cAD2C;AAEtDC,EAAAA,MAAM,EAAE;AAF8C,CAArC,CArBF,EAwBbxB,UAxBS,CAAb;AAyBA;;;;;;;AAOA,IAAIyB,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,QAAhC,EAA0C;AAC/D,SAAO,OAAOA,QAAP,KAAoB,QAApB,GAA+BD,IAAI,GAAGC,QAAtC,GAAiDD,IAAxD;AACD,CAFD;AAGA;;;;;;;;AAQA,IAAIE,mBAAmB,GAAG,SAASA,mBAAT,CAA6BF,IAA7B,EAAmCG,UAAnC,EAA+C;AACvE,MAAIC,YAAY,GAAGR,SAAS,CAACI,IAAD,CAA5B;AACA,MAAII,YAAY,IAAID,UAApB,EAAgC,OAAOA,UAAU,CAACC,YAAY,CAACP,SAAd,CAAjB;AAChC,SAAO,KAAP;AACD,CAJD;AAKA;;;;;;;;AAQA,IAAIQ,kBAAkB,GAAG,SAASA,kBAAT,CAA4BL,IAA5B,EAAkCH,SAAlC,EAA6C;AACpE,MAAIO,YAAY,GAAGR,SAAS,CAACI,IAAD,CAA5B;AACA,MAAII,YAAY,IAAIP,SAApB,EAA+B,OAAOA,SAAS,CAACO,YAAY,CAACN,MAAd,CAAhB;AAC/B,SAAO,KAAP;AACD,CAJD;;AAMA,IAAIQ,UAAU,GAAG;AACf;;;;;;;AAOAC,EAAAA,iBAAiB,EAAE,SAASA,iBAAT,CAA2BC,OAA3B,EAAoCR,IAApC,EAA0CH,SAA1C,EAAqDI,QAArD,EAA+D;AAChF,QAAIQ,KAAK,GAAG,IAAZ;;AAEA,WAAOD,OAAO,CAACE,IAAR,CAAa,UAAUC,IAAV,EAAgB;AAClCF,MAAAA,KAAK,CAACG,IAAN,CAAWZ,IAAX,EAAiBC,QAAjB;;AAEA,UAAIJ,SAAS,IAAIA,SAAS,CAACgB,KAA3B,EAAkChB,SAAS,CAACgB,KAAV,CAAgBF,IAAI,CAACG,MAArB;AAClC,aAAOH,IAAP;AACD,KALM,EAKJ,OALI,EAKK,UAAUI,GAAV,EAAe;AACzBN,MAAAA,KAAK,CAACG,IAAN,CAAWZ,IAAX,EAAiBC,QAAjB;;AAEA,UAAIJ,SAAS,IAAIA,SAAS,CAACmB,cAA3B,EAA2CnB,SAAS,CAACmB,cAAV;AAC3C,YAAMD,GAAN;AACD,KAVM,CAAP;AAWD,GAtBc;;AAwBf;;;;;;;;;AASAE,EAAAA,KAAK,EAAE,SAASA,KAAT,CAAejB,IAAf,EAAqBG,UAArB,EAAiCK,OAAjC,EAA0C;AAC/C,QAAIU,YAAY,GAAG3C,QAAQ,EAA3B;AACA,QAAI4C,aAAa,GAAGjB,mBAAmB,CAACF,IAAD,EAAOG,UAAP,CAAvC;AACA,QAAIiB,MAAJ,CAH+C,CAGnC;AACZ;;AAEA,QAAI1C,QAAQ,CAAC8B,OAAD,CAAZ,EAAuB;AACrBY,MAAAA,MAAM,GAAG,KAAKb,iBAAL,CAAuBC,OAAvB,EAAgCR,IAAhC,EAAsCmB,aAAtC,EAAqDD,YAArD,CAAT;AACD,KAFD,MAEO;AACL,UAAIG,QAAJ,CADK,CAGL;;;AACAD,MAAAA,MAAM,GAAGhD,qBAAqB,CAACiD,QAAQ,GAAG,KAAKT,IAAjB,CAArB,CAA4CU,IAA5C,CAAiDD,QAAjD,EAA2D,IAA3D,EAAiErB,IAAjE,EAAuEkB,YAAvE,CAAT;;AAEA,UAAItB,SAAS,CAACI,IAAD,CAAT,IAAmB,CAACmB,aAAxB,EAAuC;AACrC,YAAII,SAAJ,CADqC,CAGrC;;;AACAH,QAAAA,MAAM,CAACI,mBAAP,GAA6BpD,qBAAqB,CAACmD,SAAS,GAAG,KAAKC,mBAAlB,CAArB,CAA4DF,IAA5D,CAAiEC,SAAjE,EAA4E,IAA5E,EAAkFvB,IAAlF,EAAwFkB,YAAxF,CAA7B;AACD;AACF,KApB8C,CAoB7C;;;AAGF,QAAIO,WAAW,GAAG1B,gBAAgB,CAACC,IAAD,EAAOkB,YAAP,CAAlC;AACA,QAAIQ,EAAE,GAAGrB,kBAAkB,CAACL,IAAD,EAAOmB,aAAP,CAA3B;AACAtC,IAAAA,MAAM,CAAC4C,WAAD,CAAN,GAAsB;AACpBC,MAAAA,EAAE,EAAEA,EADgB;AAEpBjD,MAAAA,KAAK,EAAEA,KAAK;AAFQ,KAAtB;AAIA,WAAO2C,MAAP;AACD,GA/Dc;;AAiEf;;;;;;;AAOAI,EAAAA,mBAAmB,EAAE,SAASA,mBAAT,CAA6BxB,IAA7B,EAAmCkB,YAAnC,EAAiDf,UAAjD,EAA6D;AAChF,QAAIgB,aAAa,GAAGjB,mBAAmB,CAACF,IAAD,EAAOG,UAAP,CAAvC;;AAEA,QAAIgB,aAAJ,EAAmB;AACjB,UAAIM,WAAW,GAAG1B,gBAAgB,CAACC,IAAD,EAAOkB,YAAP,CAAlC;AACArC,MAAAA,MAAM,CAAC4C,WAAD,CAAN,CAAoBC,EAApB,GAAyBrB,kBAAkB,CAACL,IAAD,EAAOmB,aAAP,CAA3C;AACD;AACF,GA/Ec;;AAiFf;;;;;;AAMAP,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcZ,IAAd,EAAoBC,QAApB,EAA8B;AAClC,QAAI0B,SAAS,GAAG5B,gBAAgB,CAACC,IAAD,EAAOC,QAAP,CAAhC;AACA,QAAI2B,SAAS,GAAG/C,MAAM,CAAC8C,SAAD,CAAtB;;AAEA,QAAIC,SAAJ,EAAe;AACb,UAAIC,SAAJ,CADa,CAGb;;;AACA,UAAIC,EAAE,GAAGF,SAAS,CAACnD,KAAV,EAAT;AACAE,MAAAA,MAAM,CAACoD,KAAP,CAAa5D,uBAAuB,CAAC0D,SAAS,GAAG,IAAIG,MAAJ,CAAWhC,IAAX,EAAiB,SAAjB,CAAb,CAAvB,CAAiEsB,IAAjE,CAAsEO,SAAtE,EAAiFC,EAAjF,EAAqF,eAArF,CAAb,EALa,CAKwG;;AAErH,UAAIF,SAAS,CAACF,EAAd,EAAkB;AAChB;AACAE,QAAAA,SAAS,CAACF,EAAV,CAAaI,EAAb;AACD,OAVY,CAUX;;;AAGF,aAAOjD,MAAM,CAAC8C,SAAD,CAAb;AACA,aAAOG,EAAP;AACD;AACF,GA3Gc;;AA6Gf;;;AAGAG,EAAAA,SAAS,EAAEnD;AAhHI,CAAjB,C,CAiHG;;AAEH,eAAewB,UAAf","sourcesContent":["import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _bindInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/bind\";\nimport _defineProperty from \"@babel/runtime-corejs3/helpers/esm/defineProperty\";\n\nvar _CALLBACKS;\n\n/**\nCopyright 2016 Split Software\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n**/\nimport { uniqueId } from '../lang';\nimport { Logger } from '../logger/LoggerFactory';\nimport timer from './timer';\nimport thenable from '../promise/thenable'; // logger to be used on this module\n\nvar logger = new Logger('[TIME TRACKER]', {\n  showLevel: false\n}); // Map we will use for storing timers data\n\nvar timers = {}; // Tasks constants\n\nvar CONSTANTS = {\n  SDK_READY: 'Getting ready - Split SDK',\n  SDK_GET_TREATMENT: 'SDK - Get Treatment',\n  SDK_GET_TREATMENTS: 'SDK - Get Treatments',\n  SDK_GET_TREATMENT_WITH_CONFIG: 'SDK - Get Treatment with config',\n  SDK_GET_TREATMENTS_WITH_CONFIG: 'SDK - Get Treatments with config',\n  SPLITS_READY: 'Getting ready - Splits',\n  SEGMENTS_READY: 'Getting ready - Segments',\n  METRICS_PUSH: 'Pushing - Metrics',\n  IMPRESSIONS_PUSH: 'Pushing - Impressions',\n  EVENTS_PUSH: 'Pushing - Events',\n  MY_SEGMENTS_FETCH: 'Fetching - My Segments',\n  SEGMENTS_FETCH: 'Fetching - Segments',\n  SPLITS_FETCH: 'Fetching - Splits'\n}; // Tasks callbacks, if any\n\nvar CALLBACKS = (_CALLBACKS = {}, _defineProperty(_CALLBACKS, CONSTANTS.SDK_READY, {\n  collector: 'client',\n  method: 'ready'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT, {\n  collector: 'client',\n  method: 'getTreatment'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS, {\n  collector: 'client',\n  method: 'getTreatments'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT_WITH_CONFIG, {\n  collector: 'client',\n  method: 'getTreatmentWithConfig'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS_WITH_CONFIG, {\n  collector: 'client',\n  method: 'getTreatmentsWithConfig'\n}), _defineProperty(_CALLBACKS, CONSTANTS.MY_SEGMENTS_FETCH, {\n  collector: 'mySegments',\n  method: 'latency'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SEGMENTS_FETCH, {\n  collector: 'segmentChanges',\n  method: 'latency'\n}), _defineProperty(_CALLBACKS, CONSTANTS.SPLITS_FETCH, {\n  collector: 'splitChanges',\n  method: 'latency'\n}), _CALLBACKS);\n/**\n * Generates the timer keys using the task name and a modifier, if any.\n * @param {string} task - The task name\n * @param {string} modifier - (optional) The modifier, if any.\n * @return {string} The generated timer key\n */\n\nvar generateTimerKey = function generateTimerKey(task, modifier) {\n  return typeof modifier === 'string' ? task + modifier : task;\n};\n/**\n * Given the collectors map, it returns the specific collector for a given task.\n *\n * @param {string} task - The task name\n * @param {Object} collectors - The collectors map\n */\n\n\nvar getCollectorForTask = function getCollectorForTask(task, collectors) {\n  var callbackData = CALLBACKS[task];\n  if (callbackData && collectors) return collectors[callbackData.collector];\n  return false;\n};\n/**\n * Given a collector and a task, returns the callback function that should be called when we stop the timer.\n *\n * @param {string} task - The task name\n * @param {Object} collector - The collector object for the task\n */\n\n\nvar getCallbackForTask = function getCallbackForTask(task, collector) {\n  var callbackData = CALLBACKS[task];\n  if (callbackData && collector) return collector[callbackData.method];\n  return false;\n};\n\nvar TrackerAPI = {\n  /**\n   * \"Private\" method, used to attach count/countException and stop callbacks to a promise.\n   *\n   * @param {Promise} promise - The promise we want to attach the callbacks.\n   * @param {string} task - The name of the task.\n   * @param {string} modifier - (optional) The modifier for the task, if any.\n   */\n  __attachToPromise: function __attachToPromise(promise, task, collector, modifier) {\n    var _this = this;\n\n    return promise.then(function (resp) {\n      _this.stop(task, modifier);\n\n      if (collector && collector.count) collector.count(resp.status);\n      return resp;\n    })[\"catch\"](function (err) {\n      _this.stop(task, modifier);\n\n      if (collector && collector.countException) collector.countException();\n      throw err;\n    });\n  },\n\n  /**\n   * Starts tracking the time for a given task. All tasks tracked are considered \"unique\" because\n   * there may be multiple SDK instances tracking a \"generic\" task, making any task non-generic.\n   *\n   * @param {string} task - The task we are starting.\n   * @param {Object} collectors - The collectors map.\n   * @param {Promise} promise - (optional) The promise we are tracking.\n   * @return {Function | Promise} The stop function for this specific task or the promise received with the callbacks registered.\n   */\n  start: function start(task, collectors, promise) {\n    var taskUniqueId = uniqueId();\n    var taskCollector = getCollectorForTask(task, collectors);\n    var result; // If we are registering a promise with this task, we should count the status and the exceptions as well\n    // as stopping the task when the promise resolves. Then return the promise\n\n    if (thenable(promise)) {\n      result = this.__attachToPromise(promise, task, taskCollector, taskUniqueId);\n    } else {\n      var _context;\n\n      // If not, we return the stop function, as it will be stopped manually.\n      result = _bindInstanceProperty(_context = this.stop).call(_context, this, task, taskUniqueId);\n\n      if (CALLBACKS[task] && !taskCollector) {\n        var _context2;\n\n        // and provide a way for a defered setup of the collector, if needed.\n        result.setCollectorForTask = _bindInstanceProperty(_context2 = this.setCollectorForTask).call(_context2, this, task, taskUniqueId);\n      }\n    } // We start the timer, with an uniqueId attached to it's name, and save tracking info for this task.\n\n\n    var trackingKey = generateTimerKey(task, taskUniqueId);\n    var cb = getCallbackForTask(task, taskCollector);\n    timers[trackingKey] = {\n      cb: cb,\n      timer: timer()\n    };\n    return result;\n  },\n\n  /**\n   * Setup the collector for a task that reports metrics.\n   *\n   * @param {string} task - The task name\n   * @param {string} taskUniqueId - The unique identifier for this task\n   * @param {Object} collectors - The collectors map.\n   */\n  setCollectorForTask: function setCollectorForTask(task, taskUniqueId, collectors) {\n    var taskCollector = getCollectorForTask(task, collectors);\n\n    if (taskCollector) {\n      var trackingKey = generateTimerKey(task, taskUniqueId);\n      timers[trackingKey].cb = getCallbackForTask(task, taskCollector);\n    }\n  },\n\n  /**\n   * Stops the tracking of a given task.\n   *\n   * @param {string} task - The task we are starting.\n   * @param {string} modifier - (optional) The modifier for that specific task.\n   */\n  stop: function stop(task, modifier) {\n    var timerName = generateTimerKey(task, modifier);\n    var timerData = timers[timerName];\n\n    if (timerData) {\n      var _context3;\n\n      // Stop the timer and round result for readability.\n      var et = timerData.timer();\n      logger.debug(_concatInstanceProperty(_context3 = \"[\".concat(task, \"] took \")).call(_context3, et, \"ms to finish.\")); // Check if we have a tracker callback.\n\n      if (timerData.cb) {\n        // If we have a callback, we call it with the elapsed time of the task and then delete the reference.\n        timerData.cb(et);\n      } // Remove the task tracking reference.\n\n\n      delete timers[timerName];\n      return et;\n    }\n  },\n\n  /**\n   * The constants shortcut for the task names.\n   */\n  TaskNames: CONSTANTS\n}; // Our \"time tracker\" API\n\nexport default TrackerAPI;"]},"metadata":{},"sourceType":"module"}