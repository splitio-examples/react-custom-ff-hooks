{"ast":null,"code":"import _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport EventEmitter from 'events';\nvar SPLITS_READY = 2;\nvar SEGMENTS_READY = 4;\nvar SDK_FIRE_READY = SPLITS_READY | SEGMENTS_READY; // 2 + 4 = 6\n\nvar SDK_NOTIFY_UPDATE_SINCE_NOW = 8;\nvar SDK_FIRE_UPDATE = SDK_FIRE_READY | SDK_NOTIFY_UPDATE_SINCE_NOW; // 6 + 8 = 14\n\nvar Events = {\n  SDK_READY_TIMED_OUT: 'init::timeout',\n  SDK_READY: 'init::ready',\n  SDK_READY_FROM_CACHE: 'init::cache-ready',\n  SDK_SPLITS_ARRIVED: 'state::splits-arrived',\n  SDK_SEGMENTS_ARRIVED: 'state::segments-arrived',\n  SDK_SPLITS_CACHE_LOADED: 'state::splits-cache-loaded',\n  SDK_UPDATE: 'state::update',\n  READINESS_GATE_CHECK_STATE: 'state::check'\n};\n/**\n * Machine state to handle the ready / update event propagation.\n */\n\nfunction GateContext() {\n  // Splits are shared through all instances of the same SDK.\n  var splitsStatus = 0;\n  var splits = new EventEmitter();\n  splits.SDK_SPLITS_CACHE_LOADED = Events.SDK_SPLITS_CACHE_LOADED;\n  splits.SDK_SPLITS_ARRIVED = Events.SDK_SPLITS_ARRIVED; // references counter: how many\n\n  var refCount = 0;\n\n  function ReadinessGateFactory(splits, segments) {\n    var gate = new EventEmitter();\n    var segmentsStatus = 0;\n    var status = 0;\n    gate.on(Events.READINESS_GATE_CHECK_STATE, function () {\n      if (status !== SDK_FIRE_UPDATE && splitsStatus + segmentsStatus === SDK_FIRE_READY) {\n        status = SDK_FIRE_UPDATE;\n        gate.emit(Events.SDK_READY);\n      } else if (status === SDK_FIRE_UPDATE) {\n        gate.emit(Events.SDK_UPDATE);\n      }\n    });\n    splits.on(Events.SDK_SPLITS_ARRIVED, function () {\n      splitsStatus = SPLITS_READY;\n      gate.emit(Events.READINESS_GATE_CHECK_STATE);\n    });\n    splits.once(Events.SDK_SPLITS_CACHE_LOADED, function () {\n      // Make it async\n      _setTimeout(function () {\n        return gate.emit(Events.SDK_READY_FROM_CACHE);\n      }, 0);\n    });\n    segments.on(Events.SDK_SEGMENTS_ARRIVED, function () {\n      segmentsStatus = SEGMENTS_READY;\n      gate.emit(Events.READINESS_GATE_CHECK_STATE);\n    });\n    return gate;\n  }\n  /**\n   * SDK Readiness Gate Factory\n   *\n   * The ready state in the browser relay on sharing the splits ready flag across\n   * all the gates, and have an extra flag for the segments which is per gate\n   * instance.\n   */\n\n\n  function SDKReadinessGateFactory() {\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var readinessTimeoutId = 0;\n    var segments = new EventEmitter();\n    segments.SDK_SEGMENTS_ARRIVED = Events.SDK_SEGMENTS_ARRIVED;\n    var gate = ReadinessGateFactory(splits, segments);\n\n    if (timeout > 0) {\n      // Add the timeout.\n      readinessTimeoutId = _setTimeout(function () {\n        gate.emit(Events.SDK_READY_TIMED_OUT, 'Split SDK emitted SDK_READY_TIMED_OUT event.');\n      }, timeout); // Clear it if the SDK get's ready.\n\n      gate.once(Events.SDK_READY, function () {\n        return clearTimeout(readinessTimeoutId);\n      });\n    }\n\n    gate.SDK_READY = Events.SDK_READY;\n    gate.SDK_READY_FROM_CACHE = Events.SDK_READY_FROM_CACHE;\n    gate.SDK_UPDATE = Events.SDK_UPDATE;\n    gate.SDK_READY_TIMED_OUT = Events.SDK_READY_TIMED_OUT; // New Gate has been created, so increase the counter\n\n    refCount++;\n    return {\n      // Emitters\n      splits: splits,\n      segments: segments,\n      gate: gate,\n      // Cleanup listeners\n      destroy: function destroy() {\n        segments.removeAllListeners();\n        gate.removeAllListeners();\n        clearTimeout(readinessTimeoutId);\n        if (refCount > 0) refCount--;\n        if (refCount === 0) splits.removeAllListeners();\n      }\n    };\n  }\n\n  return SDKReadinessGateFactory;\n}\n\nexport default GateContext;","map":{"version":3,"sources":["/Users/talianassi/node_modules/@splitsoftware/splitio/es/readiness/index.js"],"names":["_setTimeout","EventEmitter","SPLITS_READY","SEGMENTS_READY","SDK_FIRE_READY","SDK_NOTIFY_UPDATE_SINCE_NOW","SDK_FIRE_UPDATE","Events","SDK_READY_TIMED_OUT","SDK_READY","SDK_READY_FROM_CACHE","SDK_SPLITS_ARRIVED","SDK_SEGMENTS_ARRIVED","SDK_SPLITS_CACHE_LOADED","SDK_UPDATE","READINESS_GATE_CHECK_STATE","GateContext","splitsStatus","splits","refCount","ReadinessGateFactory","segments","gate","segmentsStatus","status","on","emit","once","SDKReadinessGateFactory","timeout","arguments","length","undefined","readinessTimeoutId","clearTimeout","destroy","removeAllListeners"],"mappings":"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","sourcesContent":["import _setTimeout from \"@babel/runtime-corejs3/core-js-stable/set-timeout\";\nimport EventEmitter from 'events';\nvar SPLITS_READY = 2;\nvar SEGMENTS_READY = 4;\nvar SDK_FIRE_READY = SPLITS_READY | SEGMENTS_READY; // 2 + 4 = 6\n\nvar SDK_NOTIFY_UPDATE_SINCE_NOW = 8;\nvar SDK_FIRE_UPDATE = SDK_FIRE_READY | SDK_NOTIFY_UPDATE_SINCE_NOW; // 6 + 8 = 14\n\nvar Events = {\n  SDK_READY_TIMED_OUT: 'init::timeout',\n  SDK_READY: 'init::ready',\n  SDK_READY_FROM_CACHE: 'init::cache-ready',\n  SDK_SPLITS_ARRIVED: 'state::splits-arrived',\n  SDK_SEGMENTS_ARRIVED: 'state::segments-arrived',\n  SDK_SPLITS_CACHE_LOADED: 'state::splits-cache-loaded',\n  SDK_UPDATE: 'state::update',\n  READINESS_GATE_CHECK_STATE: 'state::check'\n};\n/**\n * Machine state to handle the ready / update event propagation.\n */\n\nfunction GateContext() {\n  // Splits are shared through all instances of the same SDK.\n  var splitsStatus = 0;\n  var splits = new EventEmitter();\n  splits.SDK_SPLITS_CACHE_LOADED = Events.SDK_SPLITS_CACHE_LOADED;\n  splits.SDK_SPLITS_ARRIVED = Events.SDK_SPLITS_ARRIVED; // references counter: how many\n\n  var refCount = 0;\n\n  function ReadinessGateFactory(splits, segments) {\n    var gate = new EventEmitter();\n    var segmentsStatus = 0;\n    var status = 0;\n    gate.on(Events.READINESS_GATE_CHECK_STATE, function () {\n      if (status !== SDK_FIRE_UPDATE && splitsStatus + segmentsStatus === SDK_FIRE_READY) {\n        status = SDK_FIRE_UPDATE;\n        gate.emit(Events.SDK_READY);\n      } else if (status === SDK_FIRE_UPDATE) {\n        gate.emit(Events.SDK_UPDATE);\n      }\n    });\n    splits.on(Events.SDK_SPLITS_ARRIVED, function () {\n      splitsStatus = SPLITS_READY;\n      gate.emit(Events.READINESS_GATE_CHECK_STATE);\n    });\n    splits.once(Events.SDK_SPLITS_CACHE_LOADED, function () {\n      // Make it async\n      _setTimeout(function () {\n        return gate.emit(Events.SDK_READY_FROM_CACHE);\n      }, 0);\n    });\n    segments.on(Events.SDK_SEGMENTS_ARRIVED, function () {\n      segmentsStatus = SEGMENTS_READY;\n      gate.emit(Events.READINESS_GATE_CHECK_STATE);\n    });\n    return gate;\n  }\n  /**\n   * SDK Readiness Gate Factory\n   *\n   * The ready state in the browser relay on sharing the splits ready flag across\n   * all the gates, and have an extra flag for the segments which is per gate\n   * instance.\n   */\n\n\n  function SDKReadinessGateFactory() {\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var readinessTimeoutId = 0;\n    var segments = new EventEmitter();\n    segments.SDK_SEGMENTS_ARRIVED = Events.SDK_SEGMENTS_ARRIVED;\n    var gate = ReadinessGateFactory(splits, segments);\n\n    if (timeout > 0) {\n      // Add the timeout.\n      readinessTimeoutId = _setTimeout(function () {\n        gate.emit(Events.SDK_READY_TIMED_OUT, 'Split SDK emitted SDK_READY_TIMED_OUT event.');\n      }, timeout); // Clear it if the SDK get's ready.\n\n      gate.once(Events.SDK_READY, function () {\n        return clearTimeout(readinessTimeoutId);\n      });\n    }\n\n    gate.SDK_READY = Events.SDK_READY;\n    gate.SDK_READY_FROM_CACHE = Events.SDK_READY_FROM_CACHE;\n    gate.SDK_UPDATE = Events.SDK_UPDATE;\n    gate.SDK_READY_TIMED_OUT = Events.SDK_READY_TIMED_OUT; // New Gate has been created, so increase the counter\n\n    refCount++;\n    return {\n      // Emitters\n      splits: splits,\n      segments: segments,\n      gate: gate,\n      // Cleanup listeners\n      destroy: function destroy() {\n        segments.removeAllListeners();\n        gate.removeAllListeners();\n        clearTimeout(readinessTimeoutId);\n        if (refCount > 0) refCount--;\n        if (refCount === 0) splits.removeAllListeners();\n      }\n    };\n  }\n\n  return SDKReadinessGateFactory;\n}\n\nexport default GateContext;"]},"metadata":{},"sourceType":"module"}