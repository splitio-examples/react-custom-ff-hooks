import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import tape from 'tape-catch';
import parser from '../../parser';
import keyParser from '../../../utils/key/parser';
tape('PARSER / if user is in segment all 100%:on',
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'ALL_KEYS',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'in segment all'
            }]);
            _context.next = 3;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 3:
            evaluation = _context.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation.treatment, 'on', "evaluator should return treatment 'on'");
            assert.equal(evaluation.label, 'in segment all', "evaluator should return label 'in segment all'");
            assert.end();

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('PARSER / if user is in segment all 100%:off',
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee2(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'ALL_KEYS',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 0
              }, {
                treatment: 'off',
                size: 100
              }],
              label: 'in segment all'
            }]);
            _context2.next = 3;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 3:
            evaluation = _context2.sent;
            assert["true"](evaluation.treatment === 'off', "treatment evaluation should throw 'off'");
            assert["true"](evaluation.label === 'in segment all', "label evaluation should throw 'in segment all'");
            assert.end();

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user is in segment all 100%:on, then no match',
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee3(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'ALL_KEYS',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'in segment all'
            }]);
            _context3.next = 3;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 3:
            evaluation = _context3.sent;
            assert.equal(_typeof(evaluator), 'function', 'evaluator should be callable');
            assert.equal(evaluation, undefined, 'evaluator should return undefined');
            assert.end();

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());
tape('PARSER / if user is in segment ["u1", "u2", "u3", "u4"] then split 100%:on',
/*#__PURE__*/
function () {
  var _ref4 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee4(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'WHITELIST',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['u1', 'u2', 'u3', 'u4']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'whitelisted'
            }]);
            _context4.next = 3;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 3:
            evaluation = _context4.sent;
            assert["true"](evaluation === undefined, 'evaluation should throw undefined');
            _context4.next = 7;
            return evaluator(keyParser('u1'), 31, 100, 31);

          case 7:
            evaluation = _context4.sent;
            assert["true"](evaluation.treatment === 'on', "treatment evaluation should throw 'on'");
            _context4.next = 11;
            return evaluator(keyParser('u3'), 31, 100, 31);

          case 11:
            evaluation = _context4.sent;
            assert["true"](evaluation.treatment === 'on', "treatment should be evaluated to 'on'");
            _context4.next = 15;
            return evaluator(keyParser('u3'), 31, 100, 31);

          case 15:
            evaluation = _context4.sent;
            assert["true"](evaluation.label === 'whitelisted', "label should be evaluated to 'whitelisted'");
            assert.end();

          case 18:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user is in segment ["u1", "u2", "u3", "u4"] then split 100%:on, negated results',
/*#__PURE__*/
function () {
  var _ref5 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee5(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'WHITELIST',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['u1', 'u2', 'u3', 'u4']
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'whitelisted'
            }]);
            _context5.next = 3;
            return evaluator(keyParser('a key'), 31, 100, 31);

          case 3:
            evaluation = _context5.sent;
            assert.equal(evaluation.treatment, 'on', "treatment evaluation should throw 'on'");
            _context5.next = 7;
            return evaluator(keyParser('u1'), 31, 100, 31);

          case 7:
            evaluation = _context5.sent;
            assert.equal(evaluation, undefined, 'evaluation should throw undefined');
            _context5.next = 11;
            return evaluator(keyParser('u3'), 31, 100, 31);

          case 11:
            evaluation = _context5.sent;
            assert.equal(evaluation, undefined, 'evaluation should throw undefined');
            _context5.next = 15;
            return evaluator(keyParser('u3'), 31, 100, 31);

          case 15:
            evaluation = _context5.sent;
            assert.equal(evaluation, undefined, 'evaluation should throw undefined');
            assert.end();

          case 18:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function (_x5) {
    return _ref5.apply(this, arguments);
  };
}());
tape('PARSER / if user.account is in list ["v1", "v2", "v3"] then split 100:on',
/*#__PURE__*/
function () {
  var _ref6 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee6(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'account'
                  },
                  matcherType: 'WHITELIST',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['v1', 'v2', 'v3']
                  },
                  unaryNumericMatcherData: null,
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'whitelisted'
            }]);
            _context6.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              account: 'v1'
            });

          case 3:
            evaluation = _context6.sent;
            assert["true"](evaluation.treatment === 'on', 'v1 is defined in the whitelist');
            assert["true"](evaluation.label === 'whitelisted', 'label should be "whitelisted"');
            _context6.next = 8;
            return evaluator(keyParser('v1'), 31, 100, 31);

          case 8:
            evaluation = _context6.sent;
            assert["true"](evaluation === undefined, 'we are looking for v1 inside the account attribute');
            _context6.next = 12;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              account: 'v4'
            });

          case 12:
            evaluation = _context6.sent;
            assert["true"](evaluation === undefined, 'v4 is not defined inside the whitelist');
            assert.end();

          case 15:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function (_x6) {
    return _ref6.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.account is in list ["v1", "v2", "v3"] then split 100:on, negated results',
/*#__PURE__*/
function () {
  var _ref7 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee7(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'account'
                  },
                  matcherType: 'WHITELIST',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: {
                    whitelist: ['v1', 'v2', 'v3']
                  },
                  unaryNumericMatcherData: null,
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'whitelisted'
            }]);
            _context7.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              account: 'v1'
            });

          case 3:
            evaluation = _context7.sent;
            assert["true"](evaluation === undefined, 'v1 is defined in the whitelist');
            _context7.next = 7;
            return evaluator(keyParser('v1'), 31, 100, 31);

          case 7:
            evaluation = _context7.sent;
            assert["true"](evaluation.treatment === 'on', 'we are looking for v1 inside the account attribute');
            assert["true"](evaluation.label === 'whitelisted', 'label should be "whitelisted"');
            _context7.next = 12;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              account: 'v4'
            });

          case 12:
            evaluation = _context7.sent;
            assert["true"](evaluation.treatment === 'on', 'v4 is not defined in the whitelist');
            assert["true"](evaluation.label === 'whitelisted', 'label should be "whitelisted"');
            assert.end();

          case 16:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function (_x7) {
    return _ref7.apply(this, arguments);
  };
}());
tape('PARSER / if user.account is in segment all then split 100:on',
/*#__PURE__*/
function () {
  var _ref8 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee8(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'ALL_KEYS',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: null,
                  betweenMatcherData: null,
                  unaryStringMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }],
              label: 'in segment all'
            }]);
            _context8.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 3:
            evaluation = _context8.sent;
            assert["true"](evaluation.treatment === 'on', 'ALL_KEYS always matches');
            assert.end();

          case 6:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function (_x8) {
    return _ref8.apply(this, arguments);
  };
}());
tape('PARSER / if user.attr is between 10 and 20 then split 100:on',
/*#__PURE__*/
function () {
  var _ref9 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee9(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'BETWEEN',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: null,
                  betweenMatcherData: {
                    dataType: 'NUMBER',
                    start: 10,
                    end: 20
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context9.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 10
            });

          case 3:
            evaluation = _context9.sent;
            assert["true"](evaluation.treatment === 'on', '10 is between 10 and 20');
            _context9.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 9
            });

          case 7:
            evaluation = _context9.sent;
            assert["true"](evaluation === undefined, '9 is not between 10 and 20');
            _context9.t0 = assert;
            _context9.next = 12;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 12:
            _context9.t1 = _context9.sent;
            _context9.t2 = undefined;
            _context9.t3 = _context9.t1 === _context9.t2;

            _context9.t0["true"].call(_context9.t0, _context9.t3, 'undefined is not between 10 and 20');

            assert.end();

          case 17:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));

  return function (_x9) {
    return _ref9.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.attr is between 10 and 20 then split 100:on, negated results',
/*#__PURE__*/
function () {
  var _ref10 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee10(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'BETWEEN',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: null,
                  betweenMatcherData: {
                    dataType: 'NUMBER',
                    start: 10,
                    end: 20
                  }
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context10.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 10
            });

          case 3:
            evaluation = _context10.sent;
            assert["true"](evaluation === undefined, '10 is between 10 and 20');
            _context10.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 9
            });

          case 7:
            evaluation = _context10.sent;
            assert["true"](evaluation.treatment === 'on', '9 is not between 10 and 20');
            _context10.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 11:
            evaluation = _context10.sent;
            assert["true"](evaluation.treatment === 'on', 'undefined is not between 10 and 20');
            assert.end();

          case 14:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function (_x10) {
    return _ref10.apply(this, arguments);
  };
}());
tape('PARSER / if user.attr <= datetime 1458240947021 then split 100:on',
/*#__PURE__*/
function () {
  var _ref11 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee11(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'LESS_THAN_OR_EQUAL_TO',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: {
                    dataType: 'DATETIME',
                    value: 1458240947021
                  },
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context11.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T18:55:47.021Z').getTime()
            });

          case 3:
            evaluation = _context11.sent;
            assert["true"](evaluation.treatment === 'on', '1458240947021 is equal');
            _context11.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T17:55:47.021Z').getTime()
            });

          case 7:
            evaluation = _context11.sent;
            assert["true"](evaluation.treatment === 'on', '1458240947020 is less than 1458240947021');
            _context11.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T19:55:47.021Z').getTime()
            });

          case 11:
            evaluation = _context11.sent;
            assert["true"](evaluation === undefined, '1458240947022 is not less than 1458240947021');
            _context11.t0 = assert;
            _context11.next = 16;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 16:
            _context11.t1 = _context11.sent;
            _context11.t2 = undefined;
            _context11.t3 = _context11.t1 === _context11.t2;

            _context11.t0["true"].call(_context11.t0, _context11.t3, 'missing attributes in the parameters list');

            assert.end();

          case 21:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));

  return function (_x11) {
    return _ref11.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.attr <= datetime 1458240947021 then split 100:on, negated results',
/*#__PURE__*/
function () {
  var _ref12 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee12(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'LESS_THAN_OR_EQUAL_TO',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: {
                    dataType: 'DATETIME',
                    value: 1458240947021
                  },
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context12.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T18:55:47.021Z').getTime()
            });

          case 3:
            evaluation = _context12.sent;
            assert["true"](evaluation === undefined, '1458240947021 is equal');
            _context12.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T17:55:47.021Z').getTime()
            });

          case 7:
            evaluation = _context12.sent;
            assert["true"](evaluation === undefined, '1458240947020 is less than 1458240947021');
            _context12.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T19:55:47.021Z').getTime()
            });

          case 11:
            evaluation = _context12.sent;
            assert["true"](evaluation.treatment === 'on', '1458240947022 is not less than 1458240947021');
            _context12.next = 15;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 15:
            evaluation = _context12.sent;
            assert["true"](evaluation.treatment === 'on', 'missing attributes in the parameters list');
            assert.end();

          case 18:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));

  return function (_x12) {
    return _ref12.apply(this, arguments);
  };
}());
tape('PARSER / if user.attr >= datetime 1458240947021 then split 100:on',
/*#__PURE__*/
function () {
  var _ref13 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee13(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'GREATER_THAN_OR_EQUAL_TO',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: {
                    dataType: 'DATETIME',
                    value: 1458240947021
                  },
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context13.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T18:55:47.021Z').getTime()
            });

          case 3:
            evaluation = _context13.sent;
            assert["true"](evaluation.treatment === 'on', '1458240947021 is equal');
            _context13.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T17:55:47.021Z').getTime()
            });

          case 7:
            evaluation = _context13.sent;
            assert["true"](evaluation === undefined, '1458240947020 is less than 1458240947021');
            _context13.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T19:55:47.021Z').getTime()
            });

          case 11:
            evaluation = _context13.sent;
            assert["true"](evaluation.treatment === 'on', '1458240947000 is greater than 1458240947021');
            _context13.t0 = assert;
            _context13.next = 16;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 16:
            _context13.t1 = _context13.sent;
            _context13.t2 = undefined;
            _context13.t3 = _context13.t1 === _context13.t2;

            _context13.t0["true"].call(_context13.t0, _context13.t3, 'missing attributes in the parameters list');

            assert.end();

          case 21:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));

  return function (_x13) {
    return _ref13.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.attr >= datetime 1458240947021 then split 100:on, negated results',
/*#__PURE__*/
function () {
  var _ref14 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee14(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'GREATER_THAN_OR_EQUAL_TO',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: {
                    dataType: 'DATETIME',
                    value: 1458240947021
                  },
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context14.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T18:55:47.021Z').getTime()
            });

          case 3:
            evaluation = _context14.sent;
            assert["true"](evaluation === undefined, '1458240947021 is equal');
            _context14.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T17:55:47.021Z').getTime()
            });

          case 7:
            evaluation = _context14.sent;
            assert["true"](evaluation.treatment === 'on', '1458240947020 is less than 1458240947021');
            _context14.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: new Date('2016-03-17T19:55:47.021Z').getTime()
            });

          case 11:
            evaluation = _context14.sent;
            assert["true"](evaluation === undefined, '1458240947000 is greater than 1458240947021');
            _context14.next = 15;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 15:
            evaluation = _context14.sent;
            assert["true"](evaluation.treatment === 'on', 'missing attributes in the parameters list');
            assert.end();

          case 18:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));

  return function (_x14) {
    return _ref14.apply(this, arguments);
  };
}());
tape('PARSER / if user.attr = datetime 1458240947021 then split 100:on',
/*#__PURE__*/
function () {
  var _ref15 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee15(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'EQUAL_TO',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: {
                    dataType: 'DATETIME',
                    value: 1458240947021
                  },
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context15.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 1458240947021
            });

          case 3:
            evaluation = _context15.sent;
            assert.equal(evaluation.treatment, 'on', '2016-03-17T18:55:47.021Z is equal to 2016-03-17T18:55:47.021Z');
            _context15.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 1458240947020
            });

          case 7:
            evaluation = _context15.sent;
            assert.equal(evaluation.treatment, 'on', '2016-03-17T18:55:47.020Z is considered equal to 2016-03-17T18:55:47.021Z');
            _context15.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 1458240947020
            });

          case 11:
            evaluation = _context15.sent;
            assert.equal(evaluation.treatment, 'on', '2016-03-17T00:00:00Z is considered equal to 2016-03-17T18:55:47.021Z');
            _context15.t0 = assert;
            _context15.next = 16;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 16:
            _context15.t1 = _context15.sent;
            _context15.t2 = undefined;

            _context15.t0.equal.call(_context15.t0, _context15.t1, _context15.t2, 'missing attributes should be evaluated to false');

            assert.end();

          case 20:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));

  return function (_x15) {
    return _ref15.apply(this, arguments);
  };
}());
tape('PARSER / NEGATED if user.attr = datetime 1458240947021 then split 100:on, negated results',
/*#__PURE__*/
function () {
  var _ref16 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee16(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  keySelector: {
                    trafficType: 'user',
                    attribute: 'attr'
                  },
                  matcherType: 'EQUAL_TO',
                  negate: true,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null,
                  unaryNumericMatcherData: {
                    dataType: 'DATETIME',
                    value: 1458240947021
                  },
                  betweenMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'on',
                size: 100
              }]
            }]);
            _context16.next = 3;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 1458240947021
            });

          case 3:
            evaluation = _context16.sent;
            assert.equal(evaluation, undefined, '2016-03-17T18:55:47.021Z is equal to 2016-03-17T18:55:47.021Z');
            _context16.next = 7;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 1458240947020
            });

          case 7:
            evaluation = _context16.sent;
            assert.equal(evaluation, undefined, '2016-03-17T18:55:47.020Z is considered equal to 2016-03-17T18:55:47.021Z');
            _context16.next = 11;
            return evaluator(keyParser('test@split.io'), 31, 100, 31, {
              attr: 1458240947020
            });

          case 11:
            evaluation = _context16.sent;
            assert.equal(evaluation, undefined, '2016-03-17T00:00:00Z is considered equal to 2016-03-17T18:55:47.021Z');
            _context16.next = 15;
            return evaluator(keyParser('test@split.io'), 31, 100, 31);

          case 15:
            evaluation = _context16.sent;
            assert.equal(evaluation.treatment, 'on', 'missing attributes should be evaluated to false');
            assert.end();

          case 18:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));

  return function (_x16) {
    return _ref16.apply(this, arguments);
  };
}());
tape('PARSER / if user is in segment all then split 20%:A,20%:B,60%:A',
/*#__PURE__*/
function () {
  var _ref17 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee17(assert) {
    var evaluator, evaluation;
    return _regeneratorRuntime.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            evaluator = parser([{
              matcherGroup: {
                combiner: 'AND',
                matchers: [{
                  matcherType: 'ALL_KEYS',
                  negate: false,
                  userDefinedSegmentMatcherData: null,
                  whitelistMatcherData: null
                }]
              },
              partitions: [{
                treatment: 'A',
                size: 20
              }, {
                treatment: 'B',
                size: 20
              }, {
                treatment: 'A',
                size: 60
              }]
            }]);
            _context17.next = 3;
            return evaluator(keyParser('aaaaa'), 31, 100, 31);

          case 3:
            evaluation = _context17.sent;
            assert.equal(evaluation.treatment, 'A', '20%:A'); // bucket 15

            _context17.next = 7;
            return evaluator(keyParser('bbbbbbbbbbbbbbbbbbb'), 31, 100, 31);

          case 7:
            evaluation = _context17.sent;
            assert.equal(evaluation.treatment, 'B', '20%:B'); // bucket 34

            _context17.next = 11;
            return evaluator(keyParser('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'), 31, 100, 31);

          case 11:
            evaluation = _context17.sent;
            assert.equal(evaluation.treatment, 'A', '60%:A'); // bucket 100

            assert.end();

          case 14:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));

  return function (_x17) {
    return _ref17.apply(this, arguments);
  };
}());