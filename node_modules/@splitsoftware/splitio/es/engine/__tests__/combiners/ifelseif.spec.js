import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import tape from 'tape-catch';
import ifElseIfCombinerFactory from '../../combiners/ifelseif';
tape('IF ELSE IF COMBINER / should correctly propagate context parameters and predicates returns value',
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(assert) {
    var inputKey, inputSeed, inputAttributes, evaluationResult, evaluator, predicates, ifElseIfEvaluator;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            evaluator = function _ref2(key, seed, attributes) {
              assert["true"](key === inputKey, 'key should be equals');
              assert["true"](seed === inputSeed, 'seed should be equals');
              assert["true"](attributes === inputAttributes, 'attributes should be equals');
              return evaluationResult;
            };

            inputKey = 'sample';
            inputSeed = 1234;
            inputAttributes = {};
            evaluationResult = 'treatment';
            predicates = [evaluator];
            ifElseIfEvaluator = ifElseIfCombinerFactory(predicates);
            _context.t0 = assert;
            _context.next = 10;
            return ifElseIfEvaluator(inputKey, inputSeed, inputAttributes);

          case 10:
            _context.t1 = _context.sent;
            _context.t2 = evaluationResult;
            _context.t3 = _context.t1 === _context.t2;
            _context.t4 = "evaluator should return ".concat(evaluationResult);

            _context.t0["true"].call(_context.t0, _context.t3, _context.t4);

            assert.end();

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('IF ELSE IF COMBINER / should stop evaluating when one matcher return a treatment',
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee2(assert) {
    var predicates, ifElseIfEvaluator;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            predicates = [function undef() {
              return undefined;
            }, function exclude() {
              return 'exclude';
            }, function alwaysTrue() {
              return 'alwaysTrue';
            }];
            ifElseIfEvaluator = ifElseIfCombinerFactory(predicates);
            _context2.t0 = assert;
            _context2.next = 5;
            return ifElseIfEvaluator();

          case 5:
            _context2.t1 = _context2.sent;

            _context2.t0.equal.call(_context2.t0, _context2.t1, 'exclude', 'exclude treatment found');

            assert.end();

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref3.apply(this, arguments);
  };
}());
tape('IF ELSE IF COMBINER / should return undefined if there is none matching rule',
/*#__PURE__*/
function () {
  var _ref4 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee3(assert) {
    var predicates, ifElseIfEvaluator;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            predicates = [function undef() {
              return undefined;
            }, function undef() {
              return undefined;
            }, function undef() {
              return undefined;
            }];
            ifElseIfEvaluator = ifElseIfCombinerFactory(predicates);
            _context3.t0 = assert;
            _context3.next = 5;
            return ifElseIfEvaluator();

          case 5:
            _context3.t1 = _context3.sent;
            _context3.t2 = undefined;
            _context3.t3 = _context3.t1 === _context3.t2;

            _context3.t0["true"].call(_context3.t0, _context3.t3);

            assert.end();

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x3) {
    return _ref4.apply(this, arguments);
  };
}());