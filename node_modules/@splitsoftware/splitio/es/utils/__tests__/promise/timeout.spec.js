import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _Date$now from "@babel/runtime-corejs3/core-js-stable/date/now";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import tape from 'tape-catch';
import timeout from '../../promise/timeout';
import { SplitTimeoutError } from '../../lang/Errors';
var baseTimeoutInMs = 20;
var resolutionValue = 'random_Value';
tape('Promise utils / timeout - What happens in the event of a timeout or no timeout at all',
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(assert) {
    var prom, ts, wrapperProm;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            prom = new _Promise(function () {});
            assert.equal(timeout(0, prom), prom, 'If we set the timeout with a value less than 1, we just get the original promise (no timeout).');
            assert.equal(timeout(-1, prom), prom, 'If we set the timeout with a value less than 1, we just get the original promise (no timeout).');
            prom.then(function () {
              return assert.fail('This should not execute');
            }, function () {
              assert.pass('This should execute on timeout expiration.');
            });
            ts = _Date$now();
            wrapperProm = timeout(baseTimeoutInMs, prom);
            assert.notEqual(wrapperProm, prom, 'If we actually set a timeout it should return a wrapping promise.');
            _context.prev = 7;
            _context.next = 10;
            return wrapperProm;

          case 10:
            assert.fail('Should not execute');
            _context.next = 18;
            break;

          case 13:
            _context.prev = 13;
            _context.t0 = _context["catch"](7);
            // The promise was rejected not resolved. Give it an error margin of 10ms since it's not predictable
            assert.ok(_Date$now() - ts < baseTimeoutInMs + 20, 'The timeout should have rejected the promise.');
            assert.ok(_context.t0 instanceof SplitTimeoutError, 'The timeout should have rejected the promise with a Split Timeout Error.');
            assert.end();

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[7, 13]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('Promise utils / timeout - What happens if the promise resolves before the timeout.',
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee2(assert) {
    var promiseResolver, prom, wrapperProm, result;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            promiseResolver = null;
            prom = new _Promise(function (res) {
              promiseResolver = res;
            });
            wrapperProm = timeout(baseTimeoutInMs * 100, prom);
            assert.notEqual(wrapperProm, prom, 'If we actually set a timeout it should return a wrapping promise.');

            _setTimeout(function () {
              // Resolve the promise before the timeout
              promiseResolver(resolutionValue);
            }, baseTimeoutInMs * 10); // This one should not reject but be resolved


            _context2.prev = 5;
            _context2.next = 8;
            return wrapperProm;

          case 8:
            result = _context2.sent;
            assert.equal(result, resolutionValue, 'The wrapper should resolve to the same value the original promise resolves.');
            assert.end();
            _context2.next = 16;
            break;

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](5);
            assert.fail('Should not execute');

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 13]]);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());
tape('Promise utils / timeout - What happens if the promise rejects before the timeout.',
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee3(assert) {
    var promiseRejecter, prom, wrapperProm;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            promiseRejecter = null;
            prom = new _Promise(function (res, rej) {
              promiseRejecter = rej;
            });
            wrapperProm = timeout(baseTimeoutInMs * 100, prom);
            assert.notEqual(wrapperProm, prom, 'If we actually set a timeout it should return a wrapping promise.');

            _setTimeout(function () {
              // Reject the promise before the timeout
              promiseRejecter(resolutionValue);
            }, baseTimeoutInMs * 10); // This one should not resolve but be rejected


            _context3.prev = 5;
            _context3.next = 8;
            return wrapperProm;

          case 8:
            assert.fail('Should not execute');
            _context3.next = 15;
            break;

          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](5);
            assert.equal(_context3.t0, resolutionValue, 'The wrapper should reject to the same error than the original promise.');
            assert.end();

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 11]]);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}());