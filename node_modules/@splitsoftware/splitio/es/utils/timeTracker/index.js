import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _defineProperty from "@babel/runtime-corejs3/helpers/esm/defineProperty";

var _CALLBACKS;

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import { uniqueId } from '../lang';
import { Logger } from '../logger/LoggerFactory';
import timer from './timer';
import thenable from '../promise/thenable'; // logger to be used on this module

var logger = new Logger('[TIME TRACKER]', {
  showLevel: false
}); // Map we will use for storing timers data

var timers = {}; // Tasks constants

var CONSTANTS = {
  SDK_READY: 'Getting ready - Split SDK',
  SDK_GET_TREATMENT: 'SDK - Get Treatment',
  SDK_GET_TREATMENTS: 'SDK - Get Treatments',
  SDK_GET_TREATMENT_WITH_CONFIG: 'SDK - Get Treatment with config',
  SDK_GET_TREATMENTS_WITH_CONFIG: 'SDK - Get Treatments with config',
  SPLITS_READY: 'Getting ready - Splits',
  SEGMENTS_READY: 'Getting ready - Segments',
  METRICS_PUSH: 'Pushing - Metrics',
  IMPRESSIONS_PUSH: 'Pushing - Impressions',
  EVENTS_PUSH: 'Pushing - Events',
  MY_SEGMENTS_FETCH: 'Fetching - My Segments',
  SEGMENTS_FETCH: 'Fetching - Segments',
  SPLITS_FETCH: 'Fetching - Splits'
}; // Tasks callbacks, if any

var CALLBACKS = (_CALLBACKS = {}, _defineProperty(_CALLBACKS, CONSTANTS.SDK_READY, {
  collector: 'client',
  method: 'ready'
}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT, {
  collector: 'client',
  method: 'getTreatment'
}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS, {
  collector: 'client',
  method: 'getTreatments'
}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT_WITH_CONFIG, {
  collector: 'client',
  method: 'getTreatmentWithConfig'
}), _defineProperty(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS_WITH_CONFIG, {
  collector: 'client',
  method: 'getTreatmentsWithConfig'
}), _defineProperty(_CALLBACKS, CONSTANTS.MY_SEGMENTS_FETCH, {
  collector: 'mySegments',
  method: 'latency'
}), _defineProperty(_CALLBACKS, CONSTANTS.SEGMENTS_FETCH, {
  collector: 'segmentChanges',
  method: 'latency'
}), _defineProperty(_CALLBACKS, CONSTANTS.SPLITS_FETCH, {
  collector: 'splitChanges',
  method: 'latency'
}), _CALLBACKS);
/**
 * Generates the timer keys using the task name and a modifier, if any.
 * @param {string} task - The task name
 * @param {string} modifier - (optional) The modifier, if any.
 * @return {string} The generated timer key
 */

var generateTimerKey = function generateTimerKey(task, modifier) {
  return typeof modifier === 'string' ? task + modifier : task;
};
/**
 * Given the collectors map, it returns the specific collector for a given task.
 *
 * @param {string} task - The task name
 * @param {Object} collectors - The collectors map
 */


var getCollectorForTask = function getCollectorForTask(task, collectors) {
  var callbackData = CALLBACKS[task];
  if (callbackData && collectors) return collectors[callbackData.collector];
  return false;
};
/**
 * Given a collector and a task, returns the callback function that should be called when we stop the timer.
 *
 * @param {string} task - The task name
 * @param {Object} collector - The collector object for the task
 */


var getCallbackForTask = function getCallbackForTask(task, collector) {
  var callbackData = CALLBACKS[task];
  if (callbackData && collector) return collector[callbackData.method];
  return false;
};

var TrackerAPI = {
  /**
   * "Private" method, used to attach count/countException and stop callbacks to a promise.
   *
   * @param {Promise} promise - The promise we want to attach the callbacks.
   * @param {string} task - The name of the task.
   * @param {string} modifier - (optional) The modifier for the task, if any.
   */
  __attachToPromise: function __attachToPromise(promise, task, collector, modifier) {
    var _this = this;

    return promise.then(function (resp) {
      _this.stop(task, modifier);

      if (collector && collector.count) collector.count(resp.status);
      return resp;
    })["catch"](function (err) {
      _this.stop(task, modifier);

      if (collector && collector.countException) collector.countException();
      throw err;
    });
  },

  /**
   * Starts tracking the time for a given task. All tasks tracked are considered "unique" because
   * there may be multiple SDK instances tracking a "generic" task, making any task non-generic.
   *
   * @param {string} task - The task we are starting.
   * @param {Object} collectors - The collectors map.
   * @param {Promise} promise - (optional) The promise we are tracking.
   * @return {Function | Promise} The stop function for this specific task or the promise received with the callbacks registered.
   */
  start: function start(task, collectors, promise) {
    var taskUniqueId = uniqueId();
    var taskCollector = getCollectorForTask(task, collectors);
    var result; // If we are registering a promise with this task, we should count the status and the exceptions as well
    // as stopping the task when the promise resolves. Then return the promise

    if (thenable(promise)) {
      result = this.__attachToPromise(promise, task, taskCollector, taskUniqueId);
    } else {
      var _context;

      // If not, we return the stop function, as it will be stopped manually.
      result = _bindInstanceProperty(_context = this.stop).call(_context, this, task, taskUniqueId);

      if (CALLBACKS[task] && !taskCollector) {
        var _context2;

        // and provide a way for a defered setup of the collector, if needed.
        result.setCollectorForTask = _bindInstanceProperty(_context2 = this.setCollectorForTask).call(_context2, this, task, taskUniqueId);
      }
    } // We start the timer, with an uniqueId attached to it's name, and save tracking info for this task.


    var trackingKey = generateTimerKey(task, taskUniqueId);
    var cb = getCallbackForTask(task, taskCollector);
    timers[trackingKey] = {
      cb: cb,
      timer: timer()
    };
    return result;
  },

  /**
   * Setup the collector for a task that reports metrics.
   *
   * @param {string} task - The task name
   * @param {string} taskUniqueId - The unique identifier for this task
   * @param {Object} collectors - The collectors map.
   */
  setCollectorForTask: function setCollectorForTask(task, taskUniqueId, collectors) {
    var taskCollector = getCollectorForTask(task, collectors);

    if (taskCollector) {
      var trackingKey = generateTimerKey(task, taskUniqueId);
      timers[trackingKey].cb = getCallbackForTask(task, taskCollector);
    }
  },

  /**
   * Stops the tracking of a given task.
   *
   * @param {string} task - The task we are starting.
   * @param {string} modifier - (optional) The modifier for that specific task.
   */
  stop: function stop(task, modifier) {
    var timerName = generateTimerKey(task, modifier);
    var timerData = timers[timerName];

    if (timerData) {
      var _context3;

      // Stop the timer and round result for readability.
      var et = timerData.timer();
      logger.debug(_concatInstanceProperty(_context3 = "[".concat(task, "] took ")).call(_context3, et, "ms to finish.")); // Check if we have a tracker callback.

      if (timerData.cb) {
        // If we have a callback, we call it with the elapsed time of the task and then delete the reference.
        timerData.cb(et);
      } // Remove the task tracking reference.


      delete timers[timerName];
      return et;
    }
  },

  /**
   * The constants shortcut for the task names.
   */
  TaskNames: CONSTANTS
}; // Our "time tracker" API

export default TrackerAPI;