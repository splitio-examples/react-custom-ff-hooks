import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import { SplitFactory } from '../../';
import splitChangesMockReal from '../mocks/splitchanges.real.json';
import map from 'lodash/map';
export default function (_x, _x2, _x3) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(settings, mock, assert) {
    var mockSplits, splitio, client, manager, manager2, splitNames, splitObj, expectedSplitObj, splitObjects;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            mock.onGet(settings.url('/splitChanges?since=-1')).reply(200, splitChangesMockReal);
            mockSplits = splitChangesMockReal;
            splitio = SplitFactory({
              core: {
                authorizationKey: '<fake-token-1>',
                key: 'marcio@split.io'
              }
            });
            client = splitio.client();
            manager = splitio.manager();
            manager2 = splitio.manager();
            assert.equal(manager, manager2, 'Does not matter how many times you call .manager(), you get the same instance for the same factory.');
            assert.equal(manager.ready, client.ready, 'And it shares all readiness methods with the main client.');
            assert.equal(manager.on, client.on, 'And it shares all readiness methods with the main client.');
            assert.equal(manager.once, client.once, 'And it shares all readiness methods with the main client.');
            assert.equal(manager.Event, client.Event, 'And it shares all readiness constants with the main client.');
            _context.next = 13;
            return client.ready();

          case 13:
            splitNames = manager.names();
            assert.equal(splitNames.length, mockSplits.splits.length, 'The manager.splits() method should return all split names on the factory storage.');
            assert.deepEqual(splitNames, map(mockSplits.splits, function (split) {
              return split.name;
            }), 'The manager.splits() method should return all split names on the factory storage.');
            splitObj = manager.split(splitNames[0]);

            expectedSplitObj = function expectedSplitObj(index) {
              return {
                'trafficType': mockSplits.splits[index].trafficTypeName,
                'name': mockSplits.splits[index].name,
                'killed': mockSplits.splits[index].killed,
                'changeNumber': mockSplits.splits[index].changeNumber,
                'treatments': map(mockSplits.splits[index].conditions[0].partitions, function (partition) {
                  return partition.treatment;
                }),
                'configs': mockSplits.splits[index].configurations || {}
              };
            };

            assert.equal(manager.split('non_existent'), null, 'Trying to get a manager.split() of a Split that does not exist returns null.');
            assert.deepEqual(splitObj, expectedSplitObj(0), 'If we ask for an existent one we receive the expected split view.');
            splitObjects = manager.splits();
            assert.equal(splitObjects.length, mockSplits.splits.length, 'The manager.splits() returns the full collection of split views.');
            assert.deepEqual(splitObjects[0], expectedSplitObj(0), 'And the split views should match the items of the collection in split view format.');
            assert.deepEqual(splitObjects[1], expectedSplitObj(1), 'And the split views should match the items of the collection in split view format.');
            client.destroy();
            assert.end();

          case 26:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref.apply(this, arguments);
}