import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import osFunction from 'os';
import ipFunction from 'ip';
import { SplitFactory } from '../../';
import SettingsFactory from '../../utils/settings';
import splitChangesMock1 from '../mocks/splitchanges.since.-1.json';
import { STANDALONE_MODE, CONSUMER_MODE } from '../../utils/constants'; // Header keys and expected values. Expected values are obtained with the runtime function evaluated with IPAddressesEnabled in true.

var HEADER_SPLITSDKMACHINEIP = 'SplitSDKMachineIP';
var HEADER_SPLITSDKMACHINENAME = 'SplitSDKMachineName';
var IP_VALUE = ipFunction.address();
var HOSTNAME_VALUE = osFunction.hostname();
var NA = 'NA'; // Refresh rates are set to 1 second to finish the test quickly. Otherwise, it would finish in 1 minute (60 seconds is the default value)

var scheduler = {
  metricsRefreshRate: 1,
  impressionsRefreshRate: 1,
  eventsPushRate: 1
}; // Config with IPAddressesEnabled set to false

var configWithIPAddressesDisabled = {
  core: {
    authorizationKey: '<fake-token>',
    IPAddressesEnabled: false
  },
  urls: {
    sdk: 'https://sdk.split-ipdisabled.io/api',
    events: 'https://events.split-ipdisabled.io/api'
  },
  scheduler: scheduler
}; // Config with IPAddressesEnabled set to true

var configWithIPAddressesEnabled = {
  core: {
    authorizationKey: '<fake-token>',
    IPAddressesEnabled: true
  },
  urls: {
    sdk: 'https://sdk.split-ipenabled.io/api',
    events: 'https://events.split-ipenabled.io/api'
  },
  scheduler: scheduler
}; // Config with default IPAddressesEnabled (true)

var configWithIPAddressesDefault = {
  core: {
    authorizationKey: '<fake-token>'
  },
  urls: {
    sdk: 'https://sdk.split-ipdefault.io/api',
    events: 'https://events.split-ipdefault.io/api'
  },
  scheduler: scheduler
};
var configSamples = [configWithIPAddressesDisabled, configWithIPAddressesEnabled, configWithIPAddressesDefault];
var postEndpoints = ['/events/bulk', '/testImpressions/bulk', '/metrics/times', '/metrics/counters'];
export default function ipAddressesSettingAssertions(mock, assert) {
  // Generator to synchronize the call of assert.end() when all Splitio configurations are run.
  var finish =
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee() {
    var CONFIG_SAMPLES_COUNT, i;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            CONFIG_SAMPLES_COUNT = configSamples.length;
            i = 0;

          case 2:
            if (!(i < CONFIG_SAMPLES_COUNT - 1)) {
              _context.next = 8;
              break;
            }

            _context.next = 5;
            return;

          case 5:
            i++;
            _context.next = 2;
            break;

          case 8:
            assert.end();

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })(); // Assert properties in impressions


  function assertImpression(IPAddressesEnabled, Mode, impression) {
    var _context2, _context3, _context4, _context5;

    assert.equal(impression.ip, IPAddressesEnabled ? IP_VALUE : Mode === STANDALONE_MODE ? false : NA, _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = "If IPAddressesEnabled, \"ip\" property in impressions must be equal to the machine ip. If not, it must be equal to \"".concat(NA, "\" for \"")).call(_context3, CONSUMER_MODE, "\" mode\" or false for \"")).call(_context2, STANDALONE_MODE, "\" mode."));
    assert.equal(impression.hostname, IPAddressesEnabled ? HOSTNAME_VALUE : Mode === STANDALONE_MODE ? false : NA, _concatInstanceProperty(_context4 = _concatInstanceProperty(_context5 = "If IPAddressesEnabled, \"hostname\" property in impressions must be equal to the machine hostname. If not, it must be equal to \"".concat(NA, "\" for \"")).call(_context5, CONSUMER_MODE, "\" mode\" or false for \"")).call(_context4, STANDALONE_MODE, "\" mode."));
  } // Assert request headers


  function assertHeaders(IPAddressesEnabled, req) {
    var _context6, _context7, _context8, _context9;

    assert.equal(HEADER_SPLITSDKMACHINEIP in req.headers, IPAddressesEnabled, _concatInstanceProperty(_context6 = _concatInstanceProperty(_context7 = "Request must ".concat(IPAddressesEnabled ? '' : 'NOT ', " include ")).call(_context7, HEADER_SPLITSDKMACHINEIP, " header if IPAddressesEnabled is ")).call(_context6, IPAddressesEnabled, "."));
    assert.equal(HEADER_SPLITSDKMACHINENAME in req.headers, IPAddressesEnabled, _concatInstanceProperty(_context8 = _concatInstanceProperty(_context9 = "Request must ".concat(IPAddressesEnabled ? '' : 'NOT ', " include ")).call(_context9, HEADER_SPLITSDKMACHINENAME, " header if IPAddressesEnabled is ")).call(_context8, IPAddressesEnabled, "."));

    if (IPAddressesEnabled) {
      assert.equal(req.headers[HEADER_SPLITSDKMACHINEIP], IP_VALUE, "If present, ".concat(HEADER_SPLITSDKMACHINEIP, " header must be equal to the machine ip."));
      assert.equal(req.headers[HEADER_SPLITSDKMACHINENAME], HOSTNAME_VALUE, "If present, ".concat(HEADER_SPLITSDKMACHINENAME, " header must be equal to the machine name."));
    }
  }

  function mockAndAssertIPAddressesEnabled(config) {
    config.impressionListener = {
      logImpression: function logImpression(impression) {
        assertImpression(config.core.IPAddressesEnabled === undefined ? true : config.core.IPAddressesEnabled, config.mode === undefined ? STANDALONE_MODE : config.mode, impression);
      }
    };
    var splitio = SplitFactory(config);
    var client = splitio.client();
    var settings = SettingsFactory(config); // Generator to synchronize the destruction of the client when all the post endpoints where called once.

    var finishConfig =
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee2() {
      var POST_ENDPOINTS_TO_TEST, i;
      return _regeneratorRuntime.wrap(function _callee2$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              POST_ENDPOINTS_TO_TEST = postEndpoints.length;
              i = 0;

            case 2:
              if (!(i < POST_ENDPOINTS_TO_TEST - 1)) {
                _context10.next = 8;
                break;
              }

              _context10.next = 5;
              return;

            case 5:
              i++;
              _context10.next = 2;
              break;

            case 8:
              client.destroy();
              finish.next();

            case 10:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee2);
    })(); // Mock GET endpoints to run client normally


    mock.onGet(settings.url('/splitChanges?since=-1')).reply(200, splitChangesMock1);
    mock.onGet(new RegExp("".concat(settings.url('/segmentChanges/'), ".*"))).reply(200, {
      since: 10,
      till: 10,
      name: 'segmentName',
      added: [],
      removed: []
    }); // Mock and assert POST endpoints

    _forEachInstanceProperty(postEndpoints).call(postEndpoints, function (postEndpoint) {
      mock.onPost(settings.url(postEndpoint)).replyOnce(function (req) {
        assertHeaders(settings.core.IPAddressesEnabled, req);
        finishConfig.next();
        return [200];
      });
    }); // Run normal client flow 


    client.on(client.Event.SDK_READY, function () {
      client.getTreatment('nicolas@split.io', 'hierarchical_splits_test');
      client.track('nicolas@split.io', 'sometraffictype', 'someEvent', 10);
    });
  }

  _forEachInstanceProperty(configSamples).call(configSamples, function (configSample) {
    return mockAndAssertIPAddressesEnabled(configSample);
  });
}