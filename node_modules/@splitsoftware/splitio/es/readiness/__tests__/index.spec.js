import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import tape from 'tape-catch';
import ReadinessGate from '../';
tape('READINESS GATE / Share splits but segments (without timeout enabled)', function (assert) {
  assert.plan(2);
  var ReadinessGateFactory = ReadinessGate();
  var readinessGate1 = ReadinessGateFactory();
  var readinessGate2 = ReadinessGateFactory();
  readinessGate1.gate.on(readinessGate1.gate.SDK_READY, function () {
    assert.pass('should be called');
  }).on(readinessGate1.gate.SDK_UPDATE, function () {
    assert.fail('should be called');
    assert.end();
  });
  readinessGate2.gate.on(readinessGate2.gate.SDK_READY, function () {
    assert.pass('should be called');
  }).on(readinessGate2.gate.SDK_UPDATE, function () {
    assert.fail('should not be called');
    assert.end();
  }); // Simulate state transitions

  _setTimeout(function () {
    readinessGate1.splits.emit(readinessGate1.splits.SDK_SPLITS_ARRIVED);
  }, 1000 * Math.random());

  _setTimeout(function () {
    readinessGate1.segments.emit(readinessGate1.segments.SDK_SEGMENTS_ARRIVED);
  }, 1000 * Math.random());

  _setTimeout(function () {
    readinessGate2.segments.emit(readinessGate2.segments.SDK_SEGMENTS_ARRIVED);
  }, 1000 * Math.random());
});
tape('READINESS GATE / Ready event should be fired once', function (assert) {
  var ReadinessGateFactory = ReadinessGate();
  var readinessGate = ReadinessGateFactory();
  var counter = 0;
  readinessGate.gate.on(readinessGate.gate.SDK_READY, function () {
    counter++;
  });
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_ARRIVED);
  readinessGate.segments.emit(readinessGate.segments.SDK_SEGMENTS_ARRIVED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_ARRIVED);
  readinessGate.segments.emit(readinessGate.segments.SDK_SEGMENTS_ARRIVED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_ARRIVED);
  readinessGate.segments.emit(readinessGate.segments.SDK_SEGMENTS_ARRIVED);
  assert.equal(counter, 1, 'should be called once');
  assert.end();
});
tape('READINESS GATE / Ready event should be fired once', function (assert) {
  var ReadinessGateFactory = ReadinessGate();
  var readinessGate = ReadinessGateFactory();
  var counter = 0;
  readinessGate.gate.on(readinessGate.gate.SDK_READY_FROM_CACHE, function () {
    counter++;
  });
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);

  _setTimeout(function () {
    readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);
  }, 0);

  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_CACHE_LOADED);

  _setTimeout(function () {
    assert.equal(counter, 1, 'should be called only once');
    assert.end();
  }, 20);
});
tape('READINESS GATE / Update event should be fired after the Ready event', function (assert) {
  var ReadinessGateFactory = ReadinessGate();
  var readinessGate = ReadinessGateFactory();
  var isReady = false;
  var counter = 0;
  readinessGate.gate.on(readinessGate.gate.SDK_READY, function () {
    counter++;
    isReady = true;
  });
  readinessGate.gate.on(readinessGate.gate.SDK_UPDATE, function () {
    isReady && counter++;
  });
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_ARRIVED);
  readinessGate.segments.emit(readinessGate.segments.SDK_SEGMENTS_ARRIVED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_ARRIVED);
  readinessGate.segments.emit(readinessGate.segments.SDK_SEGMENTS_ARRIVED);
  readinessGate.splits.emit(readinessGate.splits.SDK_SPLITS_ARRIVED);
  readinessGate.segments.emit(readinessGate.segments.SDK_SEGMENTS_ARRIVED);
  assert.equal(counter, 5, 'should count 1 ready plus 4 updates');
  assert.end();
});
tape('READINESS GATE / Segment updates should not be propagated', function (assert) {
  assert.plan(2);
  var ReadinessGateFactory = ReadinessGate();
  var readinessGate1 = ReadinessGateFactory();
  var readinessGate2 = ReadinessGateFactory();
  readinessGate2.gate.on(readinessGate2.gate.SDK_UPDATE, function () {
    assert.pass('should be called');
  });
  readinessGate1.gate.on(readinessGate1.gate.SDK_UPDATE, function () {
    assert.fail('should not be called');
  });
  readinessGate1.splits.emit(readinessGate1.splits.SDK_SPLITS_ARRIVED);
  readinessGate2.segments.emit(readinessGate2.segments.SDK_SEGMENTS_ARRIVED);
  readinessGate2.segments.emit(readinessGate2.segments.SDK_SEGMENTS_ARRIVED);
  readinessGate2.segments.emit(readinessGate2.segments.SDK_SEGMENTS_ARRIVED);
});
tape('READINESS GATE / Timeout ready event', function (assert) {
  assert.plan(1);
  var ReadinessGateFactory = ReadinessGate();
  var readiness = ReadinessGateFactory(10);
  var isReady = false;
  var timeoutCounter = 0;
  readiness.gate.on(readiness.gate.SDK_READY_TIMED_OUT, function () {
    if (!isReady) timeoutCounter++;
  });
  readiness.gate.on(readiness.gate.SDK_READY, function () {
    isReady = true;
    assert.equal(timeoutCounter, 1, 'Timeout was scheduled to be fired quickly');
  });

  _setTimeout(function () {
    readiness.splits.emit(readiness.splits.SDK_SPLITS_ARRIVED);
    readiness.segments.emit(readiness.segments.SDK_SEGMENTS_ARRIVED);
  }, 50);
});
tape('READINESS GATE / Cancel timeout if ready fired', function (assert) {
  var _context;

  assert.plan(2);
  var timeoutMs = 100;
  var ReadinessGateFactory = ReadinessGate();
  var readiness = ReadinessGateFactory(timeoutMs);
  readiness.gate.on(readiness.gate.SDK_READY_TIMED_OUT, _bindInstanceProperty(_context = assert.fail).call(_context, assert, 'SDK_READY_TIMED_OUT should have not been emitted.'));
  readiness.gate.once(readiness.gate.SDK_READY, assert.pass);

  _setTimeout(function () {
    assert.pass('After a considerably longer time than the timeout, the timeout event never fired (otherwise assert.fail was invoked).');
  }, timeoutMs * 3);

  _setTimeout(function () {
    readiness.splits.emit(readiness.splits.SDK_SPLITS_ARRIVED);
    readiness.segments.emit(readiness.segments.SDK_SEGMENTS_ARRIVED);
  }, timeoutMs * 0.8);
});
tape('READINESS GATE / Destroy after it was ready', function (assert) {
  assert.plan(1);
  var ReadinessGateFactory = ReadinessGate();
  var readiness = ReadinessGateFactory(20000);
  var counter = 0;
  readiness.gate.on(readiness.gate.SDK_UPDATE, function () {
    counter++;
  });
  readiness.splits.emit(readiness.splits.SDK_SPLITS_ARRIVED);
  readiness.segments.emit(readiness.segments.SDK_SEGMENTS_ARRIVED); // ready state

  readiness.segments.emit(readiness.segments.SDK_SEGMENTS_ARRIVED); // fires an update

  readiness.destroy(); // Destroy the gate, removing all the listeners and clearing the ready timeout.

  readiness.destroy(); // no-op

  readiness.destroy(); // no-op

  readiness.segments.emit(readiness.segments.SDK_SPLITS_ARRIVED); // fires an update

  readiness.segments.emit(readiness.segments.SDK_SEGMENTS_ARRIVED); // fires an update

  assert.equal(counter, 1, 'Second update event should be discarded');
});
tape('READINESS GATE / Destroy before it was ready', function (assert) {
  assert.plan(1);
  var ReadinessGateFactory = ReadinessGate();
  var readiness = ReadinessGateFactory(360000000); // 100hrs, test would time out if it does not work as expcted

  _setTimeout(function () {
    assert.pass('Calling destroy should have removed the readyTimeout and the test should end now.');
  }, 2000); // 2s


  readiness.destroy(); // Destroy the gate, removing all the listeners and clearing the ready timeout.
});