import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import logFactory from '../utils/logger';
import thenable from '../utils/promise/thenable';
var log = logFactory('splitio-client:cleanup');
/**
 * We'll listen for SIGTERM since it's the standard signal for server shutdown.
 *
 * If you're stopping the execution yourself via the keyboard, or by calling process.exit,
 * you should call the cleanup logic yourself, since we cannot ensure the data is sent after
 * the process is already exiting.
 */

var NodeSignalListener =
/*#__PURE__*/
function () {
  function NodeSignalListener() {
    var _context;

    _classCallCheck(this, NodeSignalListener);

    this._sigtermHandler = _bindInstanceProperty(_context = this._sigtermHandler).call(_context, this);
  }

  _createClass(NodeSignalListener, [{
    key: "start",
    value: function start(handler) {
      this.handler = handler;
      log.debug('Registering cleanup handlers.');
      process.on('SIGTERM', this._sigtermHandler);
    }
  }, {
    key: "stop",
    value: function stop() {
      log.debug('Deregistering cleanup handlers.');
      process.removeListener('SIGTERM', this._sigtermHandler);
    }
    /**
     * Call the handler, clean up listeners and emit the signal again.
     */

  }, {
    key: "_sigtermHandler",
    value: function _sigtermHandler() {
      var _this = this;

      var wrapUp = function wrapUp() {
        // Cleaned up, remove handlers.
        _this.stop(); // This handler prevented the default behaviour, start again.


        process.kill(process.pid, 'SIGTERM');
      };

      log.debug('Split SDK graceful shutdown after SIGTERM.');
      var handlerResult = null;

      try {
        handlerResult = this.handler();
      } catch (err) {
        log.error("Error with Split graceful shutdown: ".concat(err));
      }

      if (thenable(handlerResult)) {
        // Always exit, even with errors. The promise is returned for UT purposses.
        return handlerResult.then(wrapUp)["catch"](wrapUp);
      } else {
        wrapUp();
      }
    }
  }]);

  return NodeSignalListener;
}();

export { NodeSignalListener as default };