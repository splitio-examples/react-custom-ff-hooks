import _JSON$stringify from "@babel/runtime-corejs3/core-js-stable/json/stringify";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import eventsBulkRequest from '../services/events/bulk';
import eventsService from '../services/events';
import impressionsBulkRequest from '../services/impressions/bulk';
import impressionsService from '../services/impressions';
import { fromImpressionsCollector } from '../services/impressions/dto';
import logFactory from '../utils/logger';
var log = logFactory('splitio-client:cleanup'); // 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.

var UNLOAD_DOM_EVENT = 'unload';
/**
 * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.
 *
 */

var BrowserSignalListener =
/*#__PURE__*/
function () {
  function BrowserSignalListener(context) {
    var _context;

    _classCallCheck(this, BrowserSignalListener);

    this.storage = context.get(context.constants.STORAGE);
    this.settings = context.get(context.constants.SETTINGS);
    this.flushData = _bindInstanceProperty(_context = this.flushData).call(_context, this);
  }
  /**
   * start method. 
   * Called when SplitFactory is initialized. 
   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.
   */


  _createClass(BrowserSignalListener, [{
    key: "start",
    value: function start() {
      if (window && window.addEventListener) {
        log.debug('Registering flush handler when unload page event is triggered.');
        window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);
      }
    }
    /**
     * stop method. 
     * Called when client is destroyed. 
     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.
     */

  }, {
    key: "stop",
    value: function stop() {
      if (window && window.removeEventListener) {
        log.debug('Deregistering flush handler when unload page event is triggered.');
        window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);
      }
    }
    /**
     * _flushData method. 
     * Called when unload event is triggered. It flushed remaining impressions and events to the backend, 
     * using beacon API if possible, or falling back to XHR.
     */

  }, {
    key: "flushData",
    value: function flushData() {
      this._flushImpressions();

      this._flushEvents();
    }
  }, {
    key: "_flushImpressions",
    value: function _flushImpressions() {
      var impressions = this.storage.impressions; // if there are impressions in storage, send them to backend

      if (!impressions.isEmpty()) {
        var url = this.settings.url('/testImpressions/beacon');
        var impressionsPayload = fromImpressionsCollector(impressions, this.settings);

        if (!this._sendBeacon(url, impressionsPayload)) {
          impressionsService(impressionsBulkRequest(this.settings, {
            data: _JSON$stringify(impressionsPayload)
          }));
        }

        impressions.clear();
      }
    }
  }, {
    key: "_flushEvents",
    value: function _flushEvents() {
      var events = this.storage.events; // if there are events in storage, send them to backend

      if (!events.isEmpty()) {
        var url = this.settings.url('/events/beacon');
        var eventsPayload = events.toJSON();

        if (!this._sendBeacon(url, eventsPayload)) {
          eventsService(eventsBulkRequest(this.settings, {
            data: _JSON$stringify(eventsPayload)
          }));
        }

        events.clear();
      }
    }
    /**
     * _sendBeacon method.
     * Util method that check if beacon API is available, build the payload and send it.
     */

  }, {
    key: "_sendBeacon",
    value: function _sendBeacon(url, data) {
      if (navigator && navigator.sendBeacon) {
        var payload = _JSON$stringify({
          entries: data,
          token: this.settings.core.authorizationKey,
          sdk: this.settings.version
        });

        return navigator.sendBeacon(url, payload);
      }

      return false;
    }
  }]);

  return BrowserSignalListener;
}();

export { BrowserSignalListener as default };