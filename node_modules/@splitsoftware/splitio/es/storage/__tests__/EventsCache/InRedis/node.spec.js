import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _typeof from "@babel/runtime-corejs3/helpers/esm/typeof";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";

/*eslint-disable require-atomic-updates*/
import Redis from 'ioredis';
import tape from 'tape-catch';
import find from 'lodash/find';
import isEqual from 'lodash/isEqual';
import KeyBuilder from '../../../Keys';
import EventsCacheInRedis from '../../../EventsCache/InRedis';
import SettingsFactory from '../../../../utils/settings';
var settings = SettingsFactory({
  storage: {
    type: 'REDIS',
    prefix: 'UT_EVENTS_CACHE_PREFIX'
  }
});
tape('EVENTS CACHE IN REDIS / should incrementally store values in redis',
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(assert) {
    var connection, keys, key, fakeMeta, fakeEvent1, fakeEvent2, fakeEvent3, redisValues, cache, faultyCache, findMatchingElem, foundEv1, foundEv2, foundEv3;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            connection = new Redis(settings.storage.options); // This piece is being tested elsewhere.

            keys = new KeyBuilder(settings);
            key = keys.buildEventsKey();
            fakeMeta = {
              s: 'js_someversion',
              i: 'some_ip',
              n: 'some_hostname'
            };
            fakeEvent1 = {
              event: 1
            };
            fakeEvent2 = {
              event: '2'
            };
            fakeEvent3 = {
              event: null
            }; // Clean up in case there are still keys there.

            connection.del(key);
            _context.next = 10;
            return connection.lrange(key, 0, -1);

          case 10:
            redisValues = _context.sent;
            assert.equal(redisValues.length, 0, 'control assertion, there are no events previously queued.');
            cache = new EventsCacheInRedis(keys, connection, fakeMeta); // I'll use a "bad" instance so I can force an issue with the rpush command. I'll store an integer and will make the cache try to use rpush there.

            _context.next = 15;
            return connection.set('non-list-key', 10);

          case 15:
            faultyCache = new EventsCacheInRedis({
              buildEventsKey: function buildEventsKey() {
                return 'non-list-key';
              }
            }, connection, fakeMeta);
            _context.t0 = assert;
            _context.next = 19;
            return cache.track(fakeEvent1);

          case 19:
            _context.t1 = _context.sent;

            _context.t0["true"].call(_context.t0, _context.t1, 'If the queueing operation was successful, it should resolve the returned promise with "true"');

            _context.t2 = assert;
            _context.next = 24;
            return cache.track(fakeEvent2);

          case 24:
            _context.t3 = _context.sent;

            _context.t2["true"].call(_context.t2, _context.t3, 'If the queueing operation was successful, it should resolve the returned promise with "true"');

            _context.t4 = assert;
            _context.next = 29;
            return cache.track(fakeEvent3);

          case 29:
            _context.t5 = _context.sent;

            _context.t4["true"].call(_context.t4, _context.t5, 'If the queueing operation was successful, it should resolve the returned promise with "true"');

            _context.t6 = assert;
            _context.next = 34;
            return faultyCache.track(fakeEvent1);

          case 34:
            _context.t7 = _context.sent;

            _context.t6["false"].call(_context.t6, _context.t7, 'If the queueing operation was NOT successful, it should resolve the returned promise with "false" instead of rejecting it.');

            _context.t8 = assert;
            _context.next = 39;
            return faultyCache.track(fakeEvent2);

          case 39:
            _context.t9 = _context.sent;

            _context.t8["false"].call(_context.t8, _context.t9, 'If the queueing operation was NOT successful, it should resolve the returned promise with "false" instead of rejecting it.');

            _context.t10 = assert;
            _context.next = 44;
            return faultyCache.track(fakeEvent3);

          case 44:
            _context.t11 = _context.sent;

            _context.t10["false"].call(_context.t10, _context.t11, 'If the queueing operation was NOT successful, it should resolve the returned promise with "false" instead of rejecting it.');

            _context.next = 48;
            return connection.lrange(key, 0, -1);

          case 48:
            redisValues = _context.sent;
            assert.equal(redisValues.length, 3, 'After pushing we should have on Redis as many events as we have stored.');
            assert.equal(_typeof(redisValues[0]), 'string', 'All elements should be strings since those are stringified JSONs.');
            assert.equal(_typeof(redisValues[1]), 'string', 'All elements should be strings since those are stringified JSONs.');
            assert.equal(_typeof(redisValues[2]), 'string', 'All elements should be strings since those are stringified JSONs.');

            findMatchingElem = function findMatchingElem(event) {
              return find(redisValues, function (elem) {
                var parsedElem = JSON.parse(elem);
                return isEqual(parsedElem.e, event) && isEqual(parsedElem.m, fakeMeta);
              });
            };
            /* If the elements are found, then the values are correct. */


            foundEv1 = findMatchingElem(fakeEvent1);
            foundEv2 = findMatchingElem(fakeEvent2);
            foundEv3 = findMatchingElem(fakeEvent3);
            assert["true"](foundEv1, 'Events stored on redis matched the values we are expecting.');
            assert["true"](foundEv2, 'Events stored on redis matched the values we are expecting.');
            assert["true"](foundEv3, 'Events stored on redis matched the values we are expecting.'); // Clean up then end.

            _context.next = 62;
            return connection.del(key);

          case 62:
            _context.next = 64;
            return connection.quit();

          case 64:
            assert.end();

          case 65:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());