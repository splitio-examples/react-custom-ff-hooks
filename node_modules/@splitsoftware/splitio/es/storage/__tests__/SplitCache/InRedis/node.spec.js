import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";
import Redis from 'ioredis';
import tape from 'tape-catch';
import SplitCacheInRedis from '../../../SplitCache/InRedis';
import KeyBuilder from '../../../Keys';
import SettingsFactory from '../../../../utils/settings';
tape('SPLIT CACHE / Redis',
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(assert) {
    var settings, connection, keys, cache, values, splitNames, splits;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            settings = SettingsFactory({
              storage: {
                type: 'REDIS'
              }
            });
            connection = new Redis(settings.storage.options);
            keys = new KeyBuilder(settings);
            cache = new SplitCacheInRedis(keys, connection);
            _context.next = 6;
            return cache.flush();

          case 6:
            _context.next = 8;
            return cache.addSplits([['lol1', 'something'], ['lol2', 'something else']]);

          case 8:
            _context.next = 10;
            return cache.getAll();

          case 10:
            values = _context.sent;
            assert.ok(_indexOfInstanceProperty(values).call(values, 'something') !== -1);
            assert.ok(_indexOfInstanceProperty(values).call(values, 'something else') !== -1);
            _context.next = 15;
            return cache.getKeys();

          case 15:
            splitNames = _context.sent;
            assert.ok(_indexOfInstanceProperty(splitNames).call(splitNames, 'lol1') !== -1);
            assert.ok(_indexOfInstanceProperty(splitNames).call(splitNames, 'lol2') !== -1);
            _context.next = 20;
            return cache.removeSplit('lol1');

          case 20:
            _context.next = 22;
            return cache.getAll();

          case 22:
            values = _context.sent;
            assert.ok(_indexOfInstanceProperty(values).call(values, 'something') === -1);
            assert.ok(_indexOfInstanceProperty(values).call(values, 'something else') !== -1);
            _context.t0 = assert;
            _context.next = 28;
            return cache.getSplit('lol1');

          case 28:
            _context.t1 = _context.sent;
            _context.t2 = _context.t1 == null;

            _context.t0.ok.call(_context.t0, _context.t2);

            _context.t3 = assert;
            _context.next = 34;
            return cache.getSplit('lol2');

          case 34:
            _context.t4 = _context.sent;
            _context.t5 = _context.t4 === 'something else';

            _context.t3.ok.call(_context.t3, _context.t5);

            _context.next = 39;
            return cache.setChangeNumber(123);

          case 39:
            _context.t6 = assert;
            _context.next = 42;
            return cache.getChangeNumber();

          case 42:
            _context.t7 = _context.sent;
            _context.t8 = _context.t7 === 123;

            _context.t6.ok.call(_context.t6, _context.t8);

            _context.next = 47;
            return cache.getKeys();

          case 47:
            splitNames = _context.sent;
            assert.ok(_indexOfInstanceProperty(splitNames).call(splitNames, 'lol1') === -1);
            assert.ok(_indexOfInstanceProperty(splitNames).call(splitNames, 'lol2') !== -1);
            _context.next = 52;
            return cache.fetchMany(['lol1', 'lol2']);

          case 52:
            splits = _context.sent;
            assert.ok(splits.get('lol1') === null);
            assert.ok(splits.get('lol2') === 'something else');
            connection.quit();
            assert.end();

          case 57:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('SPLIT CACHE / Redis / trafficTypeExists tests',
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee2(assert) {
    var prefix, settings, connection, keys, cache, testTTName, testTTNameNoCount, testTTNameInvalid, ttKey, ttKeyNoCount, ttKeyInvalid;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            prefix = 'redis_cache_ut_prefix';
            settings = SettingsFactory({
              storage: {
                type: 'REDIS',
                prefix: prefix
              }
            });
            connection = new Redis(settings.storage.options);
            keys = new KeyBuilder(settings);
            cache = new SplitCacheInRedis(keys, connection);
            testTTName = 'tt_test_name';
            testTTNameNoCount = 'tt_test_name_2';
            testTTNameInvalid = 'tt_test_name_3';
            ttKey = keys.buildTrafficTypeKey(testTTName);
            ttKeyNoCount = keys.buildTrafficTypeKey(testTTNameNoCount);
            ttKeyInvalid = keys.buildTrafficTypeKey(testTTNameInvalid);
            _context2.next = 13;
            return cache.flush();

          case 13:
            _context2.next = 15;
            return connection.set(ttKey, 3);

          case 15:
            _context2.next = 17;
            return connection.set(ttKeyNoCount, 0);

          case 17:
            _context2.next = 19;
            return connection.set(ttKeyInvalid, 'NaN');

          case 19:
            _context2.t0 = assert;
            _context2.next = 22;
            return cache.trafficTypeExists(testTTName);

          case 22:
            _context2.t1 = _context2.sent;

            _context2.t0["true"].call(_context2.t0, _context2.t1);

            _context2.t2 = assert;
            _context2.next = 27;
            return cache.trafficTypeExists(testTTNameNoCount);

          case 27:
            _context2.t3 = _context2.sent;

            _context2.t2["false"].call(_context2.t2, _context2.t3);

            _context2.t4 = assert;
            _context2.next = 32;
            return cache.trafficTypeExists(ttKeyInvalid);

          case 32:
            _context2.t5 = _context2.sent;

            _context2.t4["false"].call(_context2.t4, _context2.t5);

            _context2.t6 = assert;
            _context2.next = 37;
            return cache.trafficTypeExists('not_existent_tt');

          case 37:
            _context2.t7 = _context2.sent;

            _context2.t6["false"].call(_context2.t6, _context2.t7);

            _context2.next = 41;
            return connection.del(ttKey);

          case 41:
            _context2.next = 43;
            return connection.del(ttKeyNoCount);

          case 43:
            _context2.next = 45;
            return connection.del(ttKeyInvalid);

          case 45:
            connection.quit();
            assert.end();

          case 47:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());