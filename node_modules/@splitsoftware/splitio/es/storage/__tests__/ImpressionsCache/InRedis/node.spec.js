import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import _JSON$stringify from "@babel/runtime-corejs3/core-js-stable/json/stringify";
import _Date$now from "@babel/runtime-corejs3/core-js-stable/date/now";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/esm/asyncToGenerator";

/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import Redis from '../../../RedisAdapter';
import tape from 'tape-catch';
import sinon from 'sinon';
import KeyBuilder from '../../../Keys';
import ImpressionsCacheInRedis from '../../../ImpressionsCache/InRedis';
import SettingsFactory from '../../../../utils/settings';
tape('IMPRESSIONS CACHE IN REDIS / should incrementally store values',
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(assert) {
    var settings, impressionsKey, testMeta, connection, keys, c, o1, o2, o3, state;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            settings = SettingsFactory({
              storage: {
                type: 'REDIS',
                prefix: 'ut_impr_cache'
              }
            });
            impressionsKey = 'ut_impr_cache.SPLITIO.impressions';
            testMeta = {
              thisIsTheMeta: true
            };
            connection = new Redis(settings.storage.options);
            keys = new KeyBuilder(settings);
            c = new ImpressionsCacheInRedis(keys, connection, testMeta);
            o1 = {
              feature: 'test1',
              keyName: 'facundo@split.io',
              treatment: 'on',
              time: _Date$now(),
              changeNumber: 1
            };
            o2 = {
              feature: 'test2',
              keyName: 'pepep@split.io',
              treatment: 'A',
              time: _Date$now(),
              bucketingKey: '1234-5678',
              label: 'is in segment',
              changeNumber: 1
            };
            o3 = {
              feature: 'test3',
              keyName: 'pipiip@split.io',
              treatment: 'B',
              time: _Date$now(),
              changeNumber: 1
            }; // cleanup

            _context.next = 11;
            return connection.del(impressionsKey);

          case 11:
            _context.next = 13;
            return c.track([o1]);

          case 13:
            _context.next = 15;
            return c.track([o2, o3]);

          case 15:
            _context.next = 17;
            return connection.lrange(impressionsKey, 0, -1);

          case 17:
            state = _context.sent;
            // This is testing both the track and the toJSON method.
            assert.deepEqual(state[0], _JSON$stringify({
              m: testMeta,
              i: {
                k: o1.keyName,
                f: o1.feature,
                t: o1.treatment,
                c: o1.changeNumber,
                m: o1.time
              }
            }));
            assert.deepEqual(state[1], _JSON$stringify({
              m: testMeta,
              i: {
                k: o2.keyName,
                b: o2.bucketingKey,
                f: o2.feature,
                t: o2.treatment,
                r: o2.label,
                c: o2.changeNumber,
                m: o2.time
              }
            }));
            assert.deepEqual(state[2], _JSON$stringify({
              m: testMeta,
              i: {
                k: o3.keyName,
                f: o3.feature,
                t: o3.treatment,
                c: o3.changeNumber,
                m: o3.time
              }
            }));
            _context.next = 23;
            return connection.del(impressionsKey);

          case 23:
            _context.next = 25;
            return connection.quit();

          case 25:
            assert.end();

          case 26:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
tape('IMPRESSIONS CACHE IN REDIS / should not resolve track before calling expire',
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee3(assert) {
    var impressionsKey, settings, testMeta, redis, keys, c, i1, i2, spy1, spy2, originalExpire;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            impressionsKey = 'ut_impr_cache_2.SPLITIO.impressions';
            settings = SettingsFactory({
              storage: {
                type: 'REDIS',
                prefix: 'ut_impr_cache_2'
              }
            });
            testMeta = {
              thisIsTheMeta: true
            };
            redis = new Redis(settings.storage.options);
            keys = new KeyBuilder(settings);
            c = new ImpressionsCacheInRedis(keys, redis, testMeta);
            i1 = {
              feature: 'test4',
              keyName: 'nicolas@split.io',
              treatment: 'off',
              time: _Date$now(),
              changeNumber: 1
            };
            i2 = {
              feature: 'test5',
              keyName: 'matias@split.io',
              treatment: 'on',
              time: _Date$now(),
              changeNumber: 2
            };
            spy1 = sinon.spy(redis, 'rpush');
            spy2 = sinon.spy(redis, 'expire'); // Crap so we can reproduce the latency as we would have on a remote server.

            originalExpire = redis.expire;

            redis.expire = function patchedForTestRedisExpire() {
              var _arguments = arguments;
              return new _Promise(function (res, rej) {
                _setTimeout(function () {
                  originalExpire.apply(redis, _arguments).then(res)["catch"](rej);
                }, 150); // 150ms of delay on the expire

              });
            }; // cleanup prior to test.


            _context3.next = 14;
            return redis.del(impressionsKey);

          case 14:
            c.track([i1, i2]).then(function () {
              redis.quit(); // Try to disconnect right away.

              assert.ok(spy1.called, 'Redis rpush was called once before executing external callback.'); // Following assertion fails if the expire takes place after disconnected and throws unhandledPromiseRejection

              assert.ok(spy2.called, 'Redis expire was called once before executing external callback.');
            })["catch"](function (e) {
              assert.fail("An error was generated from the redis expire tests: ".concat(e));
            }).then(
            /*#__PURE__*/
            _asyncToGenerator(
            /*#__PURE__*/
            _regeneratorRuntime.mark(function _callee2() {
              return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      // Finally clean up and wrap up.
                      spy1.restore();
                      spy2.restore();
                      assert.end();

                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            })));

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}());