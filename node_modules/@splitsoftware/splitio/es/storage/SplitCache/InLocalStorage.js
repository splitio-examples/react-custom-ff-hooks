import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _Number$isNaN from "@babel/runtime-corejs3/core-js-stable/number/is-nan";
import _parseInt from "@babel/runtime-corejs3/core-js-stable/parse-int";
import _slicedToArray from "@babel/runtime-corejs3/helpers/esm/slicedToArray";
import _getIterator from "@babel/runtime-corejs3/core-js/get-iterator";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import { isFinite, toNumber } from '../../utils/lang';
import usesSegments from '../../utils/splits/usesSegments';
import logFactory from '../../utils/logger';
var log = logFactory('splitio-storage:localstorage');

var SplitCacheLocalStorage =
/*#__PURE__*/
function () {
  function SplitCacheLocalStorage(keys) {
    _classCallCheck(this, SplitCacheLocalStorage);

    this.keys = keys;
  }

  _createClass(SplitCacheLocalStorage, [{
    key: "decrementCount",
    value: function decrementCount(key) {
      var count = toNumber(localStorage.getItem(key)) - 1;
      if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);
    }
  }, {
    key: "decrementCounts",
    value: function decrementCounts(split) {
      try {
        if (split) {
          if (split.trafficTypeName) {
            var ttKey = _keysInstanceProperty(this).buildTrafficTypeKey(split.trafficTypeName);

            this.decrementCount(ttKey);
          }

          if (usesSegments(split.conditions)) {
            var segmentsCountKey = _keysInstanceProperty(this).buildSplitsWithSegmentCountKey();

            this.decrementCount(segmentsCountKey);
          }
        }
      } catch (e) {
        log.error(e);
      }
    }
  }, {
    key: "incrementCounts",
    value: function incrementCounts(split) {
      try {
        if (split) {
          if (split.trafficTypeName) {
            var ttKey = _keysInstanceProperty(this).buildTrafficTypeKey(split.trafficTypeName);

            localStorage.setItem(ttKey, toNumber(localStorage.getItem(ttKey)) + 1);
          }

          if (usesSegments(split.conditions)) {
            var segmentsCountKey = _keysInstanceProperty(this).buildSplitsWithSegmentCountKey();

            localStorage.setItem(segmentsCountKey, toNumber(localStorage.getItem(segmentsCountKey)) + 1);
          }
        }
      } catch (e) {
        log.error(e);
      }
    }
  }, {
    key: "addSplit",
    value: function addSplit(splitName, split) {
      try {
        var splitKey = _keysInstanceProperty(this).buildSplitKey(splitName);

        var splitFromLocalStorage = localStorage.getItem(splitKey);
        var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;
        this.decrementCounts(previousSplit);
        localStorage.setItem(splitKey, split);
        var parsedSplit = split ? JSON.parse(split) : null;
        this.incrementCounts(parsedSplit);
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var results = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          results.push(this.addSplit(key, value));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    }
  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      try {
        var split = this.getSplit(splitName);
        localStorage.removeItem(_keysInstanceProperty(this).buildSplitKey(splitName));
        var parsedSplit = JSON.parse(split);
        this.decrementCounts(parsedSplit);
        return 1;
      } catch (e) {
        log.error(e);
        return 0;
      }
    }
    /**
     * Bulk delete of splits from LocalStorage. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplits",
    value: function removeSplits(names) {
      var i = 0;
      var len = names.length;
      var counter = 0;

      for (; i < len; i++) {
        counter += this.removeSplit(names[i]);
      }

      return counter;
    }
  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      return localStorage.getItem(_keysInstanceProperty(this).buildSplitKey(splitName));
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      try {
        localStorage.setItem(_keysInstanceProperty(this).buildSplitsTillKey(), changeNumber + '');
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      var n = -1;
      var value = localStorage.getItem(_keysInstanceProperty(this).buildSplitsTillKey());

      if (value !== null) {
        value = _parseInt(value, 10);
        return _Number$isNaN(value) ? n : value;
      }

      return n;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var len = localStorage.length;
      var accum = [];
      var cur = 0;

      while (cur < len) {
        var key = localStorage.key(cur);
        var value = key && localStorage.getItem(key);
        if (key != null && _keysInstanceProperty(this).isSplitKey(key) && value) accum.push(value);
        cur++;
      }

      return accum;
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var len = localStorage.length;
      var accum = [];
      var cur = 0;

      while (cur < len) {
        var key = localStorage.key(cur);
        if (key != null && _keysInstanceProperty(this).isSplitKey(key)) accum.push(_keysInstanceProperty(this).extractKey(key));
        cur++;
      }

      return accum;
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      var ttCount = toNumber(localStorage.getItem(_keysInstanceProperty(this).buildTrafficTypeKey(trafficType)));
      return isFinite(ttCount) && ttCount > 0;
    }
  }, {
    key: "usesSegments",
    value: function usesSegments() {
      // If there are no splits in the cache yet, assume we need them.
      if (this.getChangeNumber() === -1) return true;
      var storedCount = localStorage.getItem(_keysInstanceProperty(this).buildSplitsWithSegmentCountKey());
      var splitsWithSegmentsCount = storedCount === null ? 0 : toNumber(storedCount);

      if (isFinite(splitsWithSegmentsCount)) {
        return splitsWithSegmentsCount > 0;
      } else {
        return true;
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      log.info('Flushing localStorage');
      localStorage.clear();
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this = this;

      var splits = new _Map();

      _forEachInstanceProperty(splitNames).call(splitNames, function (splitName) {
        splits.set(splitName, localStorage.getItem(_keysInstanceProperty(_this).buildSplitKey(splitName)));
      });

      return splits;
    }
    /**
     * Check if the splits information is already stored in cache.
     * In this function we could add more code to check if the data is valid.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return this.getChangeNumber() > -1;
    }
  }]);

  return SplitCacheLocalStorage;
}();

export default SplitCacheLocalStorage;