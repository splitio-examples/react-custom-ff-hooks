import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _toConsumableArray from "@babel/runtime-corejs3/helpers/esm/toConsumableArray";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Number$isNaN from "@babel/runtime-corejs3/core-js-stable/number/is-nan";
import _parseInt from "@babel/runtime-corejs3/core-js-stable/parse-int";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import _slicedToArray from "@babel/runtime-corejs3/helpers/esm/slicedToArray";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import { isFinite } from '../../utils/lang';
import logFactory from '../../utils/logger';
var log = logFactory('splitio-storage:redis');
/**
 * Discard errors for an answer of multiple operations.
 */

var processPipelineAnswer = function processPipelineAnswer(results) {
  return _reduceInstanceProperty(results).call(results, function (accum, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        err = _ref2[0],
        value = _ref2[1];

    if (err === null) accum.push(value);
    return accum;
  }, []);
};

var SplitCacheInRedis =
/*#__PURE__*/
function () {
  function SplitCacheInRedis(keys, redis) {
    var _this = this;

    _classCallCheck(this, SplitCacheInRedis);

    this.redis = redis;
    this.keys = keys;
    this.redisError = false;
    this.redis.on('error', function (e) {
      _this.redisError = e;
    });
    this.redis.on('connect', function () {
      _this.redisError = false;
    });
  }

  _createClass(SplitCacheInRedis, [{
    key: "addSplit",
    value: function addSplit(splitName, split) {
      return this.redis.set(_keysInstanceProperty(this).buildSplitKey(splitName), split).then(function (status) {
        return status === 'OK';
      });
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var _this2 = this;

      if (entries.length) {
        var cmds = _mapInstanceProperty(entries).call(entries, function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          return ['set', _keysInstanceProperty(_this2).buildSplitKey(key), value];
        });

        return this.redis.pipeline(cmds).exec().then(processPipelineAnswer).then(function (answers) {
          return _mapInstanceProperty(answers).call(answers, function (status) {
            return status === 'OK';
          });
        });
      } else {
        return [true];
      }
    }
    /**
     * Remove a given split from Redis. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      return this.redis.del(_keysInstanceProperty(this).buildSplitKey(splitName));
    }
    /**
     * Bulk delete of splits from Redis. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplits",
    value: function removeSplits(names) {
      var _this3 = this;

      if (names.length) {
        return this.redis.del(_mapInstanceProperty(names).call(names, function (n) {
          return _keysInstanceProperty(_this3).buildSplitKey(n);
        }));
      } else {
        return _Promise.resolve(0);
      }
    }
    /**
     * Get split definition or null if it's not defined.
     */

  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      if (this.redisError) {
        log.error(this.redisError);
        throw this.redisError;
      }

      return this.redis.get(_keysInstanceProperty(this).buildSplitKey(splitName));
    }
    /**
     * Set till number.
     *
     * @TODO pending error handling
     */

  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      return this.redis.set(_keysInstanceProperty(this).buildSplitsTillKey(), changeNumber + '').then(function (status) {
        return status === 'OK';
      });
    }
    /**
     * Get till number or null if it's not defined.
     *
     * @TODO pending error handling
     */

  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      return this.redis.get(_keysInstanceProperty(this).buildSplitsTillKey()).then(function (value) {
        var i = _parseInt(value, 10);

        return _Number$isNaN(i) ? -1 : i;
      });
    }
    /**
     * @TODO we need to benchmark which is the maximun number of commands we could
     *       pipeline without kill redis performance.
     */

  }, {
    key: "getAll",
    value: function getAll() {
      var _context,
          _this4 = this;

      return _keysInstanceProperty(_context = this.redis).call(_context, _keysInstanceProperty(this).searchPatternForSplitKeys()).then(function (listOfKeys) {
        return _this4.redis.pipeline(_mapInstanceProperty(listOfKeys).call(listOfKeys, function (k) {
          return ['get', k];
        })).exec();
      }).then(processPipelineAnswer);
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var _context2,
          _this5 = this;

      return _keysInstanceProperty(_context2 = this.redis).call(_context2, _keysInstanceProperty(this).searchPatternForSplitKeys()).then(function (listOfKeys) {
        return _mapInstanceProperty(listOfKeys).call(listOfKeys, _keysInstanceProperty(_this5).extractKey);
      });
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      // If there is a number there should be > 0, otherwise the TT is considered as not existent.
      return this.redis.get(_keysInstanceProperty(this).buildTrafficTypeKey(trafficType)).then(function (ttCount) {
        ttCount = _parseInt(ttCount, 10);

        if (!isFinite(ttCount) || ttCount < 0) {
          log.info("Could not validate traffic type existance of ".concat(trafficType, " due to data corruption of some sorts."));
          return false;
        }

        return ttCount > 0;
      })["catch"](function (e) {
        var _context3;

        log.error(_concatInstanceProperty(_context3 = "Could not validate traffic type existance of ".concat(trafficType, " due to an error: ")).call(_context3, e, ".")); // If there is an error, bypass the validation so the event can get tracked.

        return true;
      });
    } // noop, just keeping the interface. This is used by client-side implementations only.

  }, {
    key: "usesSegments",
    value: function usesSegments() {
      return true;
    }
    /**
     * Delete everything in the current database.
     *
     * @NOTE documentation says it never fails.
     */

  }, {
    key: "flush",
    value: function flush() {
      return this.redis.flushdb().then(function (status) {
        return status === 'OK';
      });
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this6 = this,
          _this$redis;

      if (this.redisError) {
        log.error(this.redisError);
        throw this.redisError;
      }

      var splits = new _Map();

      var keys = _mapInstanceProperty(splitNames).call(splitNames, function (splitName) {
        return _keysInstanceProperty(_this6).buildSplitKey(splitName);
      });

      return (_this$redis = this.redis).mget.apply(_this$redis, _toConsumableArray(keys)).then(function (splitDefinitions) {
        _forEachInstanceProperty(splitNames).call(splitNames, function (splitName, idx) {
          splits.set(splitName, splitDefinitions[idx]);
        });

        return _Promise.resolve(splits);
      })["catch"](function (e) {
        log.error("Could not grab splits due to an error: ".concat(e, "."));
        return _Promise.reject(e);
      });
    }
    /**
     * Check if the splits information is already stored in cache. Redis would actually be the cache.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return false;
    }
  }]);

  return SplitCacheInRedis;
}();

export default SplitCacheInRedis;