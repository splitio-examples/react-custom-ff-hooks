import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import logFactory from '../../../utils/logger';
var log = logFactory('splitio-storage:localstorage');
var DEFINED = '1';

var SegmentCacheInLocalStorage =
/*#__PURE__*/
function () {
  function SegmentCacheInLocalStorage(keys) {
    _classCallCheck(this, SegmentCacheInLocalStorage);

    this.keys = keys;
  }

  _createClass(SegmentCacheInLocalStorage, [{
    key: "addToSegment",
    value: function addToSegment(segmentName
    /*, segmentKeys: Array<string>*/
    ) {
      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);

      try {
        localStorage.setItem(segmentKey, DEFINED);
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "removeFromSegment",
    value: function removeFromSegment(segmentName
    /*, segmentKeys: Array<string>*/
    ) {
      var segmentKey = _keysInstanceProperty(this).buildSegmentNameKey(segmentName);

      try {
        localStorage.removeItem(segmentKey);
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "resetSegments",
    value: function resetSegments(segmentNames) {
      var _context,
          _this = this;

      var isDiff = false;
      var index; // Scan current values from localStorage

      var storedSegmentNames = _reduceInstanceProperty(_context = _Object$keys(localStorage)).call(_context, function (accum, key) {
        var segmentName = _keysInstanceProperty(_this).extractSegmentName(key);

        if (segmentName) accum.push(segmentName);
        return accum;
      }, []); // Extreme fast => everything is empty


      if (segmentNames.length === 0 && storedSegmentNames.length === segmentNames.length) return isDiff; // Quick path

      if (storedSegmentNames.length !== segmentNames.length) {
        isDiff = true;

        _forEachInstanceProperty(storedSegmentNames).call(storedSegmentNames, function (segmentName) {
          return _this.removeFromSegment(segmentName);
        });

        _forEachInstanceProperty(segmentNames).call(segmentNames, function (segmentName) {
          return _this.addToSegment(segmentName);
        });
      } else {
        // Slowest path => we need to find at least 1 difference because
        for (index = 0; index < segmentNames.length && _indexOfInstanceProperty(storedSegmentNames).call(storedSegmentNames, segmentNames[index]) !== -1; index++) {// TODO: why empty statement?
        }

        if (index < segmentNames.length) {
          isDiff = true;

          _forEachInstanceProperty(storedSegmentNames).call(storedSegmentNames, function (segmentName) {
            return _this.removeFromSegment(segmentName);
          });

          _forEachInstanceProperty(segmentNames).call(segmentNames, function (segmentName) {
            return _this.addToSegment(segmentName);
          });
        }
      }

      return isDiff;
    }
  }, {
    key: "isInSegment",
    value: function isInSegment(segmentName
    /*, key: string*/
    ) {
      return localStorage.getItem(_keysInstanceProperty(this).buildSegmentNameKey(segmentName)) === DEFINED;
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber()
    /*segmentName: string, changeNumber: number*/
    {
      return true;
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber()
    /*segmentName: string*/
    {
      return -1;
    }
  }, {
    key: "registerSegment",
    value: function registerSegment()
    /*segment: string*/
    {
      return false;
    }
  }, {
    key: "registerSegments",
    value: function registerSegments()
    /*segments: Iterable<string>*/
    {
      return false;
    }
  }, {
    key: "getRegisteredSegments",
    value: function getRegisteredSegments() {
      return [];
    }
  }, {
    key: "flush",
    value: function flush() {
      log.info('Flushing localStorage');
      localStorage.clear();
    }
  }]);

  return SegmentCacheInLocalStorage;
}();

export default SegmentCacheInLocalStorage;