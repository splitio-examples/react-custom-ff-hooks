import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _toConsumableArray from "@babel/runtime-corejs3/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime-corejs3/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime-corejs3/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime-corejs3/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime-corejs3/helpers/esm/inherits";
import ioredis from 'ioredis';
import { merge, isString } from '../utils/lang';
import thenable from '../utils/promise/thenable';
import timeout from '../utils/promise/timeout';
import LogFactory from '../utils/logger';
var log = LogFactory('splitio-storage:redis-adapter'); // If we ever decide to fully wrap every method, there's a Commander.getBuiltinCommands from ioredis.

var METHODS_TO_PROMISE_WRAP = ['set', 'exec', 'del', 'get', 'keys', 'sadd', 'srem', 'sismember', 'smembers', 'incr', 'rpush', 'pipeline', 'expire', 'mget']; // Not part of the settings since it'll vary on each storage. We should be removing storage specific logic from elsewhere.

var DEFAULT_OPTIONS = {
  connectionTimeout: 10000,
  operationTimeout: 5000
}; // Library specifics.

var DEFAULT_LIBRARY_OPTIONS = {
  enableOfflineQueue: false,
  connectTimeout: DEFAULT_OPTIONS.connectionTimeout,
  lazyConnect: false
};
/**
 * Redis adapter on top of the library of choice (written with ioredis) for some extra control.
 */

var RedisAdapter =
/*#__PURE__*/
function (_ioredis) {
  _inherits(RedisAdapter, _ioredis);

  function RedisAdapter(storageSettings) {
    var _getPrototypeOf2, _context;

    var _this;

    _classCallCheck(this, RedisAdapter);

    var options = RedisAdapter._defineOptions(storageSettings); // Call the ioredis constructor


    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RedisAdapter)).call.apply(_getPrototypeOf2, _concatInstanceProperty(_context = [this]).call(_context, _toConsumableArray(RedisAdapter._defineLibrarySettings(options)))));
    _this._options = options;
    _this._notReadyCommandsQueue = [];
    _this._runningCommands = new _Set();

    _this._listenToEvents();

    _this._setTimeoutWrappers();

    _this._setDisconnectWrapper();

    return _this;
  }

  _createClass(RedisAdapter, [{
    key: "_listenToEvents",
    value: function _listenToEvents() {
      var _this2 = this;

      this.once('ready', function () {
        var _context2;

        var commandsCount = _this2._notReadyCommandsQueue ? _this2._notReadyCommandsQueue.length : 0;
        log.info("Redis connection established. Queued commands: ".concat(commandsCount, "."));
        commandsCount && _forEachInstanceProperty(_context2 = _this2._notReadyCommandsQueue).call(_context2, function (queued) {
          log.info("Executing queued ".concat(queued.name, " command."));
          queued.command().then(queued.resolve)["catch"](queued.reject);
        }); // After the SDK is ready for the first time we'll stop queueing commands. This is just so we can keep handling BUR for them.

        _this2._notReadyCommandsQueue = false;
      });
      this.once('close', function () {
        log.info('Redis connection closed.');
      });
    }
  }, {
    key: "_setTimeoutWrappers",
    value: function _setTimeoutWrappers() {
      var instance = this;

      _forEachInstanceProperty(METHODS_TO_PROMISE_WRAP).call(METHODS_TO_PROMISE_WRAP, function (method) {
        var originalMethod = instance[method];

        instance[method] = function () {
          var params = arguments;

          function commandWrapper() {
            log.debug("Executing ".concat(method, ".")); // Return original method

            var result = originalMethod.apply(instance, params);

            if (thenable(result)) {
              // For handling pending commands on disconnect, add to the set and remove once finished.
              // On sync commands there's no need, only thenables.
              instance._runningCommands.add(result);

              var cleanUpRunningCommandsCb = function cleanUpRunningCommandsCb(res) {
                instance._runningCommands["delete"](result);

                return res;
              }; // Both success and error remove from queue.


              result.then(cleanUpRunningCommandsCb, cleanUpRunningCommandsCb);
              return timeout(instance._options.operationTimeout, result)["catch"](function (err) {
                var _context3, _context4;

                log.error(_concatInstanceProperty(_context3 = _concatInstanceProperty(_context4 = "".concat(method, " operation threw an error or exceeded configured timeout of ")).call(_context4, instance._options.operationTimeout, "ms. Message: ")).call(_context3, err)); // Handling is not the adapter responsibility.

                throw err;
              });
            }

            return result;
          }

          if (instance._notReadyCommandsQueue) {
            return new _Promise(function (res, rej) {
              instance._notReadyCommandsQueue.unshift({
                resolve: res,
                reject: rej,
                command: commandWrapper,
                name: method.toUpperCase()
              });
            });
          } else {
            return commandWrapper();
          }
        };
      });
    }
  }, {
    key: "_setDisconnectWrapper",
    value: function _setDisconnectWrapper() {
      var instance = this;
      var originalMethod = instance.disconnect;

      instance.disconnect = function disconnect() {
        var params = arguments;

        _setTimeout(function deferedDisconnect() {
          if (instance._runningCommands.size > 0) {
            var _context5;

            log.info("Attempting to disconnect but there are ".concat(instance._runningCommands.size, " commands still waiting for resolution. Defering disconnection until those finish."));

            _Promise.all(_valuesInstanceProperty(_context5 = instance._runningCommands).call(_context5)).then(function () {
              log.debug('Pending commands finished successfully, disconnecting.');
              originalMethod.apply(instance, params);
            })["catch"](function (e) {
              log.warn("Pending commands finished with error: ".concat(e, ". Proceeding with disconnection."));
              originalMethod.apply(instance, params);
            });
          } else {
            log.debug('No commands pending execution, disconnect.'); // Nothing pending, just proceed.

            originalMethod.apply(instance, params);
          }
        }, 10);
      };
    }
    /**
     * Receives the options and returns an array of parameters for the ioredis constructor.
     * Keeping both redis setup options for backwards compatibility.
     */

  }], [{
    key: "_defineLibrarySettings",
    value: function _defineLibrarySettings(options) {
      var opts = merge({}, DEFAULT_LIBRARY_OPTIONS);
      var result = [opts];

      if (!isString(options.url)) {
        merge(opts, {
          // If it's not the string URL, merge the params separately.
          host: options.host,
          port: options.port,
          db: options.db,
          password: options.pass
        });
      } else {
        // If it IS the string URL, that'll be the first param for ioredis.
        result.unshift(options.url);
      }

      return result;
    }
    /**
     * Parses the options into what we care about.
     */

  }, {
    key: "_defineOptions",
    value: function _defineOptions(_ref) {
      var connectionTimeout = _ref.connectionTimeout,
          operationTimeout = _ref.operationTimeout,
          url = _ref.url,
          host = _ref.host,
          port = _ref.port,
          db = _ref.db,
          pass = _ref.pass;
      var parsedOptions = {
        connectionTimeout: connectionTimeout,
        operationTimeout: operationTimeout,
        url: url,
        host: host,
        port: port,
        db: db,
        pass: pass
      };
      return merge({}, DEFAULT_OPTIONS, parsedOptions);
    }
  }]);

  return RedisAdapter;
}(ioredis);

export { RedisAdapter as default };