import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _Date$now from "@babel/runtime-corejs3/core-js-stable/date/now";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import logFactory from '../utils/logger';
var log = logFactory('splitio-client');
import { evaluateFeature, evaluateFeatures } from '../engine/evaluator';
import ImpressionTracker from '../trackers/impression';
import ImpressionsTracker from '../trackers/impressions';
import tracker from '../utils/timeTracker';
import thenable from '../utils/promise/thenable';
import { matching, bucketing } from '../utils/key/factory';
/* asynchronous validations that live on the client. */

import { validateSplitExistance, validateTrafficTypeExistance } from '../utils/inputValidation';
import { SDK_NOT_READY } from '../utils/labels';
import { CONTROL } from '../utils/constants';

function queueEventsCallback(_ref, tracked) {
  var _context, _context2, _context3, _context4, _context5;

  var eventTypeId = _ref.eventTypeId,
      trafficTypeName = _ref.trafficTypeName,
      key = _ref.key,
      value = _ref.value,
      timestamp = _ref.timestamp,
      properties = _ref.properties;

  // Logging every prop would be too much.
  var msg = _concatInstanceProperty(_context = _concatInstanceProperty(_context2 = _concatInstanceProperty(_context3 = _concatInstanceProperty(_context4 = _concatInstanceProperty(_context5 = "event of type \"".concat(eventTypeId, "\" for traffic type \"")).call(_context5, trafficTypeName, "\". Key: ")).call(_context4, key, ". Value: ")).call(_context3, value, ". Timestamp: ")).call(_context2, timestamp, ". ")).call(_context, properties ? 'With properties.' : 'With no properties.');

  if (tracked) {
    log.info("Successfully qeued ".concat(msg));
  } else {
    log.warn("Failed to queue ".concat(msg));
  }

  return tracked;
}

function ClientFactory(context) {
  var storage = context.get(context.constants.STORAGE);
  var metricCollectors = context.get(context.constants.COLLECTORS);
  var impressionTracker = ImpressionTracker(context);
  var impressionsTracker = ImpressionsTracker(context);

  function getTreatment(key, splitName, attributes) {
    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];
    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);
    var evaluation = evaluateFeature(key, splitName, attributes, storage);

    if (thenable(evaluation)) {
      return evaluation.then(function (res) {
        return processEvaluation(res, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, "getTreatment".concat(withConfig ? 'withConfig' : ''));
      });
    } else {
      return processEvaluation(evaluation, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, "getTreatment".concat(withConfig ? 'withConfig' : ''));
    }
  }

  function getTreatmentWithConfig(key, splitName, attributes) {
    return getTreatment(key, splitName, attributes, true);
  }

  function getTreatments(key, splitNames, attributes) {
    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var taskToBeTracked = tracker.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];
    var stopLatencyTracker = tracker.start(taskToBeTracked, metricCollectors);
    var results = {};

    var wrapUp = function wrapUp(evaluationResults) {
      var _context6;

      _forEachInstanceProperty(_context6 = _Object$keys(evaluationResults)).call(_context6, function (splitName) {
        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, false, impressionsTracker.queue, withConfig, "getTreatments".concat(withConfig ? 'withConfig' : ''));
      });

      impressionsTracker.track();
      stopLatencyTracker();
      return results;
    };

    var evaluations = evaluateFeatures(key, splitNames, attributes, storage);
    return thenable(evaluations) ? evaluations.then(function (res) {
      return wrapUp(res);
    }) : wrapUp(evaluations);
  }

  function getTreatmentsWithConfig(key, splitNames, attributes) {
    return getTreatments(key, splitNames, attributes, true);
  } // Internal function


  function processEvaluation(evaluation, splitName, key, attributes) {
    var _context7, _context8, _context9;

    var stopLatencyTracker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var impressionsTracker = arguments.length > 5 ? arguments[5] : undefined;
    var withConfig = arguments.length > 6 ? arguments[6] : undefined;
    var invokingMethodName = arguments.length > 7 ? arguments[7] : undefined;
    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);
    var matchingKey = matching(key);
    var bucketingKey = bucketing(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.

    if (!isSdkReady) {
      evaluation = {
        treatment: CONTROL,
        label: SDK_NOT_READY
      };
    }

    var _evaluation = evaluation,
        treatment = _evaluation.treatment,
        label = _evaluation.label,
        changeNumber = _evaluation.changeNumber,
        _evaluation$config = _evaluation.config,
        config = _evaluation$config === void 0 ? null : _evaluation$config;
    log.info(_concatInstanceProperty(_context7 = _concatInstanceProperty(_context8 = _concatInstanceProperty(_context9 = "Split: ".concat(splitName, ". Key: ")).call(_context9, matchingKey, ". Evaluation: ")).call(_context8, treatment, ". Label: ")).call(_context7, label));

    if (validateSplitExistance(context, splitName, label, invokingMethodName)) {
      log.info('Queueing corresponding impression.');
      impressionsTracker({
        feature: splitName,
        keyName: matchingKey,
        treatment: treatment,
        time: _Date$now(),
        bucketingKey: bucketingKey,
        label: label,
        changeNumber: changeNumber
      }, attributes);
    }

    stopLatencyTracker && stopLatencyTracker();

    if (withConfig) {
      return {
        treatment: treatment,
        config: config
      };
    }

    return treatment;
  }

  function track(key, trafficTypeName, eventTypeId) {
    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;
    var matchingKey = matching(key);

    var timestamp = _Date$now();

    var eventData = {
      eventTypeId: eventTypeId,
      trafficTypeName: trafficTypeName,
      value: value,
      timestamp: timestamp,
      key: matchingKey,
      properties: properties
    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.

    validateTrafficTypeExistance(trafficTypeName, context, 'track');
    var tracked = storage.events.track(eventData, size);

    if (thenable(tracked)) {
      return tracked.then(_bindInstanceProperty(queueEventsCallback).call(queueEventsCallback, null, eventData));
    } else {
      return queueEventsCallback(eventData, tracked);
    }
  }

  return {
    getTreatment: getTreatment,
    getTreatmentWithConfig: getTreatmentWithConfig,
    getTreatments: getTreatments,
    getTreatmentsWithConfig: getTreatmentsWithConfig,
    track: track
  };
}

export default ClientFactory;