"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _LoggerFactory = require("../../logger/LoggerFactory");

var _indexSpec = require("./index.spec.js");

/* eslint-disable no-console */
var isNode = typeof process !== 'undefined' && process.version ? true : false;
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / setLogLevel utility function', function (assert) {
  assert.equal((0, _typeof2.default)(_LoggerFactory.setLogLevel), 'function', 'setLogLevel should be a function');
  assert.doesNotThrow(_LoggerFactory.setLogLevel, 'Calling setLogLevel should not throw an error.');
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / LogLevels exposed mappings', function (assert) {
  assert.deepEqual(_LoggerFactory.LogLevels, _indexSpec.LOG_LEVELS, 'Exposed log levels should contain the levels we want.');
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class shape', function (assert) {
  assert.equal((0, _typeof2.default)(_LoggerFactory.Logger), 'function', 'Logger should be a class we can instantiate.');
  var logger = new _LoggerFactory.Logger('test-category', {});
  assert.equal((0, _typeof2.default)(logger.debug), 'function', 'instance.debug should be a method.');
  assert.equal((0, _typeof2.default)(logger.info), 'function', 'instance.info should be a method.');
  assert.equal((0, _typeof2.default)(logger.warn), 'function', 'instance.warn should be a method.');
  assert.equal((0, _typeof2.default)(logger.error), 'function', 'instance.error should be a method.');
  assert.end();
});
var LOG_LEVELS_IN_ORDER = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'NONE'];
/* Utility function to avoid repeating too much code */

function testLogLevels(levelToTest, assert) {
  // Builds the expected message.
  var buildExpectedMessage = function buildExpectedMessage(lvl, category, msg, showLevel) {
    var res = '';
    if (showLevel) res += '[' + lvl + ']' + (lvl.length === 4 ? '  ' : ' ');
    res += category + ' => ';
    res += msg;
    return res;
  }; // Runs the suite with the given value for showLevel option.


  var runTests = function runTests(showLevel, displayAllErrors) {
    var _context;

    var logLevelLogsCounter = 0;
    var testForNoLog = false;
    var logMethod = levelToTest.toLowerCase();
    var logCategory = (0, _concat.default)(_context = "test-category-".concat(logMethod)).call(_context, displayAllErrors ? 'displayAllErrors' : '');
    var instance = new _LoggerFactory.Logger(logCategory, {
      showLevel: showLevel,
      displayAllErrors: displayAllErrors
    });
    (0, _forEach.default)(LOG_LEVELS_IN_ORDER).call(LOG_LEVELS_IN_ORDER, function (logLevel, i) {
      var _context2, _context3, _context4, _context5, _context6, _context7;

      var logMsg = (0, _concat.default)(_context2 = (0, _concat.default)(_context3 = (0, _concat.default)(_context4 = "Test log for level ".concat(levelToTest, " (")).call(_context4, displayAllErrors ? 'But all errors are configured to display' : 'Errors not forced to display', ") with showLevel: ")).call(_context3, showLevel, " ")).call(_context2, logLevelLogsCounter);
      var expectedMessage = buildExpectedMessage(levelToTest, logCategory, logMsg, showLevel);
      var consoleMethodToUse = !isNode && levelToTest === _indexSpec.LOG_LEVELS.ERROR ? 'error' : 'log'; // Log error should always be visible.

      if (logMethod === _indexSpec.LOG_LEVELS.ERROR.toLowerCase() && displayAllErrors) testForNoLog = false; // Set the logLevel for this iteration.

      (0, _LoggerFactory.setLogLevel)(_LoggerFactory.LogLevels[logLevel]); // Call the method

      instance[logMethod](logMsg); // Assert if console.log was called.

      assert[testForNoLog ? 'notOk' : 'ok'](console[consoleMethodToUse].calledWith(expectedMessage), (0, _concat.default)(_context5 = (0, _concat.default)(_context6 = (0, _concat.default)(_context7 = "Calling ".concat(logMethod, " method should ")).call(_context7, testForNoLog ? 'NOT ' : '', "log with ")).call(_context6, logLevel, " log level. ")).call(_context5, displayAllErrors ? 'But all errors are configured to display.' : ''));

      if ((0, _indexOf.default)(LOG_LEVELS_IN_ORDER).call(LOG_LEVELS_IN_ORDER, levelToTest) <= i) {
        testForNoLog = true;
      }

      logLevelLogsCounter++;
    });
  }; // Stub console.log & error


  _sinon.default.spy(console, 'log');

  console.error && _sinon.default.spy(console, 'error'); // Show logLevel

  runTests(true);
  runTests(true, true); // Hide logLevel

  runTests(false);
  runTests(false, true); // Restore stub.

  console.log.restore();
  console.error && console.error.restore && console.error.restore();
}

(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.debug', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.DEBUG, assert);
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.info', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.INFO, assert);
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.warn', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.WARN, assert);
  assert.end();
});
(0, _tapeCatch.default)('SPLIT LOGGER FACTORY / Logger class public methods behaviour - instance.error', function (assert) {
  testLogLevels(_LoggerFactory.LogLevels.ERROR, assert, true);
  assert.end();
});