"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/symbol"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _create = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/create"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var proxyquireStrict = _proxyquire.default.noCallThru();

var loggerMock = {
  warn: _sinon.default.stub(),
  error: _sinon.default.stub()
};

function LogFactoryMock() {
  return loggerMock;
}

var _proxyquireStrict = proxyquireStrict('../../inputValidation/eventValue', {
  '../logger': LogFactoryMock
}),
    validateEventValue = _proxyquireStrict.validateEventValue;
/* We'll reset the history for the next test */


function resetStubs() {
  loggerMock.warn.resetHistory();
  loggerMock.error.resetHistory();
}

var invalidValues = [[], function () {}, false, true, {}, (0, _create.default)({}), 'something', NaN, -Infinity, Infinity, new _promise.default(function (res) {
  return res;
}), (0, _symbol.default)('asd')];
(0, _tapeCatch.default)('INPUT VALIDATION for Event Values', function (t) {
  t.test('Should return the passed value if it is a valid finite number without logging any errors', function (assert) {
    assert.equal(validateEventValue(50, 'some_method_eventValue'), 50, 'It should return the passed number if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.equal(validateEventValue(-50, 'some_method_eventValue'), -50, 'It should return the passed number if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return the passed value if it is a null or undefined (since it is optional) without logging any errors', function (assert) {
    assert.equal(validateEventValue(null, 'some_method_eventValue'), null, 'It should return the passed number if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.equal(validateEventValue(undefined, 'some_method_eventValue'), undefined, 'It should return the passed number if it is valid.');
    assert.notOk(loggerMock.error.called, 'Should not log any errors.');
    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
  t.test('Should return false and log error if event value is not a valid finite number', function (assert) {
    for (var i = 0; i < invalidValues.length; i++) {
      var invalidValue = invalidValues[i];
      assert.equal(validateEventValue(invalidValue, 'test_method'), false, 'Invalid event values should always return false.');
      assert.ok(loggerMock.error.calledWithExactly('test_method: value must be a finite number.'), 'Should log the error for the invalid event value.');
      loggerMock.error.resetHistory();
    }

    assert.notOk(loggerMock.warn.called, 'It should have not logged any warnings.');
    resetStubs();
    assert.end();
  });
});