"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/date/now"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _logger = _interopRequireDefault(require("../utils/logger"));

var _evaluator = require("../engine/evaluator");

var _impression = _interopRequireDefault(require("../trackers/impression"));

var _impressions = _interopRequireDefault(require("../trackers/impressions"));

var _timeTracker = _interopRequireDefault(require("../utils/timeTracker"));

var _thenable = _interopRequireDefault(require("../utils/promise/thenable"));

var _factory = require("../utils/key/factory");

var _inputValidation = require("../utils/inputValidation");

var _labels = require("../utils/labels");

var _constants = require("../utils/constants");

var log = (0, _logger.default)('splitio-client');

function queueEventsCallback(_ref, tracked) {
  var _context, _context2, _context3, _context4, _context5;

  var eventTypeId = _ref.eventTypeId,
      trafficTypeName = _ref.trafficTypeName,
      key = _ref.key,
      value = _ref.value,
      timestamp = _ref.timestamp,
      properties = _ref.properties;
  // Logging every prop would be too much.
  var msg = (0, _concat.default)(_context = (0, _concat.default)(_context2 = (0, _concat.default)(_context3 = (0, _concat.default)(_context4 = (0, _concat.default)(_context5 = "event of type \"".concat(eventTypeId, "\" for traffic type \"")).call(_context5, trafficTypeName, "\". Key: ")).call(_context4, key, ". Value: ")).call(_context3, value, ". Timestamp: ")).call(_context2, timestamp, ". ")).call(_context, properties ? 'With properties.' : 'With no properties.');

  if (tracked) {
    log.info("Successfully qeued ".concat(msg));
  } else {
    log.warn("Failed to queue ".concat(msg));
  }

  return tracked;
}

function ClientFactory(context) {
  var storage = context.get(context.constants.STORAGE);
  var metricCollectors = context.get(context.constants.COLLECTORS);
  var impressionTracker = (0, _impression.default)(context);
  var impressionsTracker = (0, _impressions.default)(context);

  function getTreatment(key, splitName, attributes) {
    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var taskToBeTracked = _timeTracker.default.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];

    var stopLatencyTracker = _timeTracker.default.start(taskToBeTracked, metricCollectors);

    var evaluation = (0, _evaluator.evaluateFeature)(key, splitName, attributes, storage);

    if ((0, _thenable.default)(evaluation)) {
      return evaluation.then(function (res) {
        return processEvaluation(res, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, "getTreatment".concat(withConfig ? 'withConfig' : ''));
      });
    } else {
      return processEvaluation(evaluation, splitName, key, attributes, stopLatencyTracker, impressionTracker.track, withConfig, "getTreatment".concat(withConfig ? 'withConfig' : ''));
    }
  }

  function getTreatmentWithConfig(key, splitName, attributes) {
    return getTreatment(key, splitName, attributes, true);
  }

  function getTreatments(key, splitNames, attributes) {
    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var taskToBeTracked = _timeTracker.default.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];

    var stopLatencyTracker = _timeTracker.default.start(taskToBeTracked, metricCollectors);

    var results = {};

    var wrapUp = function wrapUp(evaluationResults) {
      var _context6;

      (0, _forEach.default)(_context6 = (0, _keys.default)(evaluationResults)).call(_context6, function (splitName) {
        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, false, impressionsTracker.queue, withConfig, "getTreatments".concat(withConfig ? 'withConfig' : ''));
      });
      impressionsTracker.track();
      stopLatencyTracker();
      return results;
    };

    var evaluations = (0, _evaluator.evaluateFeatures)(key, splitNames, attributes, storage);
    return (0, _thenable.default)(evaluations) ? evaluations.then(function (res) {
      return wrapUp(res);
    }) : wrapUp(evaluations);
  }

  function getTreatmentsWithConfig(key, splitNames, attributes) {
    return getTreatments(key, splitNames, attributes, true);
  } // Internal function


  function processEvaluation(evaluation, splitName, key, attributes) {
    var _context7, _context8, _context9;

    var stopLatencyTracker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var impressionsTracker = arguments.length > 5 ? arguments[5] : undefined;
    var withConfig = arguments.length > 6 ? arguments[6] : undefined;
    var invokingMethodName = arguments.length > 7 ? arguments[7] : undefined;
    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);
    var matchingKey = (0, _factory.matching)(key);
    var bucketingKey = (0, _factory.bucketing)(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.

    if (!isSdkReady) {
      evaluation = {
        treatment: _constants.CONTROL,
        label: _labels.SDK_NOT_READY
      };
    }

    var _evaluation = evaluation,
        treatment = _evaluation.treatment,
        label = _evaluation.label,
        changeNumber = _evaluation.changeNumber,
        _evaluation$config = _evaluation.config,
        config = _evaluation$config === void 0 ? null : _evaluation$config;
    log.info((0, _concat.default)(_context7 = (0, _concat.default)(_context8 = (0, _concat.default)(_context9 = "Split: ".concat(splitName, ". Key: ")).call(_context9, matchingKey, ". Evaluation: ")).call(_context8, treatment, ". Label: ")).call(_context7, label));

    if ((0, _inputValidation.validateSplitExistance)(context, splitName, label, invokingMethodName)) {
      log.info('Queueing corresponding impression.');
      impressionsTracker({
        feature: splitName,
        keyName: matchingKey,
        treatment: treatment,
        time: (0, _now.default)(),
        bucketingKey: bucketingKey,
        label: label,
        changeNumber: changeNumber
      }, attributes);
    }

    stopLatencyTracker && stopLatencyTracker();

    if (withConfig) {
      return {
        treatment: treatment,
        config: config
      };
    }

    return treatment;
  }

  function track(key, trafficTypeName, eventTypeId) {
    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;
    var matchingKey = (0, _factory.matching)(key);
    var timestamp = (0, _now.default)();
    var eventData = {
      eventTypeId: eventTypeId,
      trafficTypeName: trafficTypeName,
      value: value,
      timestamp: timestamp,
      key: matchingKey,
      properties: properties
    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.

    (0, _inputValidation.validateTrafficTypeExistance)(trafficTypeName, context, 'track');
    var tracked = storage.events.track(eventData, size);

    if ((0, _thenable.default)(tracked)) {
      return tracked.then((0, _bind.default)(queueEventsCallback).call(queueEventsCallback, null, eventData));
    } else {
      return queueEventsCallback(eventData, tracked);
    }
  }

  return {
    getTreatment: getTreatment,
    getTreatmentWithConfig: getTreatmentWithConfig,
    getTreatments: getTreatments,
    getTreatmentsWithConfig: getTreatmentsWithConfig,
    track: track
  };
}

var _default = ClientFactory;
exports.default = _default;