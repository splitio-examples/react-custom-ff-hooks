"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _startsWithInstanceProperty = require("@babel/runtime-corejs3/core-js-stable/instance/starts-with");

require("core-js/modules/es.object.to-string");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _client = _interopRequireDefault(require("./client"));

var _inputValidation = require("../utils/inputValidation");

var _lang = require("../utils/lang");

var _constants = require("../utils/constants");

/**
 * We will validate the input before actually executing the client methods. We should "guard" the client here,
 * while not polluting the "real" implementation of those methods.
 */
function ClientInputValidationLayer(context, isKeyBinded, isTTBinded) {
  var settings = context.get(context.constants.SETTINGS);
  var isStorageSync = settings.storage.type !== _constants.STORAGE_REDIS; // instantiate the client

  var client = (0, _client.default)(context); // Keep a reference to the original methods

  var clientGetTreatment = client.getTreatment;
  var clientGetTreatmentWithConfig = client.getTreatmentWithConfig;
  var clientGetTreatments = client.getTreatments;
  var clientGetTreatmentsWithConfig = client.getTreatmentsWithConfig;
  var clientTrack = client.track;
  /**
   * Avoid repeating this validations code
   */

  function validateEvaluationParams(maybeKey, maybeSplitOrSplits, maybeAttributes, methodName) {
    var multi = (0, _startsWithInstanceProperty(_lang))(methodName, 'getTreatments');
    var key = isKeyBinded ? maybeKey : (0, _inputValidation.validateKey)(maybeKey, methodName);
    var splitOrSplits = multi ? (0, _inputValidation.validateSplits)(maybeSplitOrSplits, methodName) : (0, _inputValidation.validateSplit)(maybeSplitOrSplits, methodName);
    var attributes = (0, _inputValidation.validateAttributes)(maybeAttributes, methodName);
    var isOperational = (0, _inputValidation.validateIfDestroyed)(context);
    (0, _inputValidation.validateIfReady)(context, methodName);
    var valid = isOperational && key && splitOrSplits && attributes !== false;
    return {
      valid: valid,
      key: key,
      splitOrSplits: splitOrSplits,
      attributes: attributes
    };
  }

  client.getTreatment = function getTreatment(maybeKey, maybeSplit, maybeAttributes) {
    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatment');

    if (params.valid) {
      return clientGetTreatment(params.key, params.splitOrSplits, params.attributes);
    } else {
      if (isStorageSync) return _constants.CONTROL;
      return _promise.default.resolve(_constants.CONTROL);
    }
  };

  client.getTreatmentWithConfig = function getTreatmentWithConfig(maybeKey, maybeSplit, maybeAttributes) {
    var params = validateEvaluationParams(maybeKey, maybeSplit, maybeAttributes, 'getTreatmentWithConfig');

    if (params.valid) {
      return clientGetTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);
    } else {
      if (isStorageSync) return (0, _assign.default)({}, _constants.CONTROL_WITH_CONFIG);
      return _promise.default.resolve((0, _assign.default)({}, _constants.CONTROL_WITH_CONFIG));
    }
  };

  client.getTreatments = function getTreatments(maybeKey, maybeSplits, maybeAttributes) {
    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatments');

    if (params.valid) {
      return clientGetTreatments(params.key, params.splitOrSplits, params.attributes);
    } else {
      var _context;

      var res = {};
      if (params.splitOrSplits) (0, _forEach.default)(_context = params.splitOrSplits).call(_context, function (split) {
        return res[split] = _constants.CONTROL;
      });
      if (isStorageSync) return res;
      return _promise.default.resolve(res);
    }
  };

  client.getTreatmentsWithConfig = function getTreatmentsWithConfig(maybeKey, maybeSplits, maybeAttributes) {
    var params = validateEvaluationParams(maybeKey, maybeSplits, maybeAttributes, 'getTreatmentsWithConfig');

    if (params.valid) {
      return clientGetTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);
    } else {
      var _context2;

      var res = {};
      if (params.splitOrSplits) (0, _forEach.default)(_context2 = params.splitOrSplits).call(_context2, function (split) {
        return res[split] = (0, _assign.default)({}, _constants.CONTROL_WITH_CONFIG);
      });
      if (isStorageSync) return res;
      return _promise.default.resolve(res);
    }
  };

  client.track = function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {
    var key = isKeyBinded ? maybeKey : (0, _inputValidation.validateKey)(maybeKey, 'track');
    var tt = isTTBinded ? maybeTT : (0, _inputValidation.validateTrafficType)(maybeTT, 'track');
    var event = (0, _inputValidation.validateEvent)(maybeEvent, 'track');
    var eventValue = (0, _inputValidation.validateEventValue)(maybeEventValue, 'track');

    var _validateEventPropert = (0, _inputValidation.validateEventProperties)(maybeProperties),
        properties = _validateEventPropert.properties,
        size = _validateEventPropert.size;

    var isOperational = (0, _inputValidation.validateIfDestroyed)(context);

    if (isOperational && key && tt && event && eventValue !== false && properties !== false) {
      return clientTrack(key, tt, event, eventValue, properties, size);
    } else {
      if (isStorageSync) return false;
      return _promise.default.resolve(false);
    }
  };

  return client;
}

var _default = ClientInputValidationLayer;
exports.default = _default;