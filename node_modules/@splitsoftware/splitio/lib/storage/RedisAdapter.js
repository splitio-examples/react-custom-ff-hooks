"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));

var _ioredis2 = _interopRequireDefault(require("ioredis"));

var _lang = require("../utils/lang");

var _thenable = _interopRequireDefault(require("../utils/promise/thenable"));

var _timeout = _interopRequireDefault(require("../utils/promise/timeout"));

var _logger = _interopRequireDefault(require("../utils/logger"));

var log = (0, _logger.default)('splitio-storage:redis-adapter'); // If we ever decide to fully wrap every method, there's a Commander.getBuiltinCommands from ioredis.

var METHODS_TO_PROMISE_WRAP = ['set', 'exec', 'del', 'get', 'keys', 'sadd', 'srem', 'sismember', 'smembers', 'incr', 'rpush', 'pipeline', 'expire', 'mget']; // Not part of the settings since it'll vary on each storage. We should be removing storage specific logic from elsewhere.

var DEFAULT_OPTIONS = {
  connectionTimeout: 10000,
  operationTimeout: 5000
}; // Library specifics.

var DEFAULT_LIBRARY_OPTIONS = {
  enableOfflineQueue: false,
  connectTimeout: DEFAULT_OPTIONS.connectionTimeout,
  lazyConnect: false
};
/**
 * Redis adapter on top of the library of choice (written with ioredis) for some extra control.
 */

var RedisAdapter =
/*#__PURE__*/
function (_ioredis) {
  (0, _inherits2.default)(RedisAdapter, _ioredis);

  function RedisAdapter(storageSettings) {
    var _getPrototypeOf2, _context;

    var _this;

    (0, _classCallCheck2.default)(this, RedisAdapter);

    var options = RedisAdapter._defineOptions(storageSettings); // Call the ioredis constructor


    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(RedisAdapter)).call.apply(_getPrototypeOf2, (0, _concat.default)(_context = [this]).call(_context, (0, _toConsumableArray2.default)(RedisAdapter._defineLibrarySettings(options)))));
    _this._options = options;
    _this._notReadyCommandsQueue = [];
    _this._runningCommands = new _set.default();

    _this._listenToEvents();

    _this._setTimeoutWrappers();

    _this._setDisconnectWrapper();

    return _this;
  }

  (0, _createClass2.default)(RedisAdapter, [{
    key: "_listenToEvents",
    value: function _listenToEvents() {
      var _this2 = this;

      this.once('ready', function () {
        var _context2;

        var commandsCount = _this2._notReadyCommandsQueue ? _this2._notReadyCommandsQueue.length : 0;
        log.info("Redis connection established. Queued commands: ".concat(commandsCount, "."));
        commandsCount && (0, _forEach.default)(_context2 = _this2._notReadyCommandsQueue).call(_context2, function (queued) {
          log.info("Executing queued ".concat(queued.name, " command."));
          queued.command().then(queued.resolve).catch(queued.reject);
        }); // After the SDK is ready for the first time we'll stop queueing commands. This is just so we can keep handling BUR for them.

        _this2._notReadyCommandsQueue = false;
      });
      this.once('close', function () {
        log.info('Redis connection closed.');
      });
    }
  }, {
    key: "_setTimeoutWrappers",
    value: function _setTimeoutWrappers() {
      var instance = this;
      (0, _forEach.default)(METHODS_TO_PROMISE_WRAP).call(METHODS_TO_PROMISE_WRAP, function (method) {
        var originalMethod = instance[method];

        instance[method] = function () {
          var params = arguments;

          function commandWrapper() {
            log.debug("Executing ".concat(method, ".")); // Return original method

            var result = originalMethod.apply(instance, params);

            if ((0, _thenable.default)(result)) {
              // For handling pending commands on disconnect, add to the set and remove once finished.
              // On sync commands there's no need, only thenables.
              instance._runningCommands.add(result);

              var cleanUpRunningCommandsCb = function cleanUpRunningCommandsCb(res) {
                instance._runningCommands.delete(result);

                return res;
              }; // Both success and error remove from queue.


              result.then(cleanUpRunningCommandsCb, cleanUpRunningCommandsCb);
              return (0, _timeout.default)(instance._options.operationTimeout, result).catch(function (err) {
                var _context3, _context4;

                log.error((0, _concat.default)(_context3 = (0, _concat.default)(_context4 = "".concat(method, " operation threw an error or exceeded configured timeout of ")).call(_context4, instance._options.operationTimeout, "ms. Message: ")).call(_context3, err)); // Handling is not the adapter responsibility.

                throw err;
              });
            }

            return result;
          }

          if (instance._notReadyCommandsQueue) {
            return new _promise.default(function (res, rej) {
              instance._notReadyCommandsQueue.unshift({
                resolve: res,
                reject: rej,
                command: commandWrapper,
                name: method.toUpperCase()
              });
            });
          } else {
            return commandWrapper();
          }
        };
      });
    }
  }, {
    key: "_setDisconnectWrapper",
    value: function _setDisconnectWrapper() {
      var instance = this;
      var originalMethod = instance.disconnect;

      instance.disconnect = function disconnect() {
        var params = arguments;
        (0, _setTimeout2.default)(function deferedDisconnect() {
          if (instance._runningCommands.size > 0) {
            var _context5;

            log.info("Attempting to disconnect but there are ".concat(instance._runningCommands.size, " commands still waiting for resolution. Defering disconnection until those finish."));

            _promise.default.all((0, _values.default)(_context5 = instance._runningCommands).call(_context5)).then(function () {
              log.debug('Pending commands finished successfully, disconnecting.');
              originalMethod.apply(instance, params);
            }).catch(function (e) {
              log.warn("Pending commands finished with error: ".concat(e, ". Proceeding with disconnection."));
              originalMethod.apply(instance, params);
            });
          } else {
            log.debug('No commands pending execution, disconnect.'); // Nothing pending, just proceed.

            originalMethod.apply(instance, params);
          }
        }, 10);
      };
    }
    /**
     * Receives the options and returns an array of parameters for the ioredis constructor.
     * Keeping both redis setup options for backwards compatibility.
     */

  }], [{
    key: "_defineLibrarySettings",
    value: function _defineLibrarySettings(options) {
      var opts = (0, _lang.merge)({}, DEFAULT_LIBRARY_OPTIONS);
      var result = [opts];

      if (!(0, _lang.isString)(options.url)) {
        (0, _lang.merge)(opts, {
          // If it's not the string URL, merge the params separately.
          host: options.host,
          port: options.port,
          db: options.db,
          password: options.pass
        });
      } else {
        // If it IS the string URL, that'll be the first param for ioredis.
        result.unshift(options.url);
      }

      return result;
    }
    /**
     * Parses the options into what we care about.
     */

  }, {
    key: "_defineOptions",
    value: function _defineOptions(_ref) {
      var connectionTimeout = _ref.connectionTimeout,
          operationTimeout = _ref.operationTimeout,
          url = _ref.url,
          host = _ref.host,
          port = _ref.port,
          db = _ref.db,
          pass = _ref.pass;
      var parsedOptions = {
        connectionTimeout: connectionTimeout,
        operationTimeout: operationTimeout,
        url: url,
        host: host,
        port: port,
        db: db,
        pass: pass
      };
      return (0, _lang.merge)({}, DEFAULT_OPTIONS, parsedOptions);
    }
  }]);
  return RedisAdapter;
}(_ioredis2.default);

exports.default = RedisAdapter;