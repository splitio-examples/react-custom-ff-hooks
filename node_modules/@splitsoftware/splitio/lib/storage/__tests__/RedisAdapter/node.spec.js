"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _setImmediate2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-immediate"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _reduce = _interopRequireDefault(require("lodash/reduce"));

var _context;

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context4; (0, _forEach.default)(_context4 = ownKeys(Object(source), true)).call(_context4, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context5; (0, _forEach.default)(_context5 = ownKeys(Object(source))).call(_context5, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

// The list of methods we're wrapping on a promise (for timeout) on the adapter.
var METHODS_TO_PROMISE_WRAP = ['set', 'exec', 'del', 'get', 'keys', 'sadd', 'srem', 'sismember', 'smembers', 'incr', 'rpush', 'pipeline', 'expire', 'mget'];
var ioredisMock = (0, _reduce.default)((0, _concat.default)(_context = []).call(_context, METHODS_TO_PROMISE_WRAP, ['disconnect']), function (acc, methodName) {
  acc[methodName] = _sinon.default.stub().resolves(methodName);
  return acc;
}, {
  once: _sinon.default.stub()
});
var loggerMock = {
  debug: _sinon.default.stub(),
  info: _sinon.default.stub(),
  warn: _sinon.default.stub(),
  error: _sinon.default.stub()
};
var constructorParams = false;

function ioredis() {
  constructorParams = arguments;
  (0, _merge.default)(this, ioredisMock);
}

function LogFactory() {
  return loggerMock;
}

var timeoutPromiseResolvers = [];

var timeout = _sinon.default.spy(function timeout(ms, originalPromise) {
  var resolvers = {};
  var promise = new _promise.default(function (res, rej) {
    resolvers.res = res;
    resolvers.rej = rej;
    resolvers.originalPromise = originalPromise;
  });
  timeoutPromiseResolvers.unshift(resolvers);
  return promise;
}); // Mocking deps ¯\_(ツ)_/¯


var RedisAdapter = (0, _proxyquire.default)('../../RedisAdapter', {
  'ioredis': ioredis,
  '../utils/logger': {
    default: LogFactory
  },
  '../utils/promise/timeout': {
    default: timeout
  }
}).default;
/**
 * Logs here won't be changing much, so we could validate those. It's not important the exact message but what do they represent.
 */

(0, _tapeCatch.default)('STORAGE Redis Adapter / Class', function (assert) {
  assert.equal(RedisAdapter.__proto__, ioredis, 'The returned class extends from the library of choice (ioredis).');
  var instance = new RedisAdapter({
    url: 'redis://localhost:6379/0',
    connectionTimeout: 10000,
    operationTimeout: 10000
  });
  assert.true(instance instanceof RedisAdapter, 'Of course created instance should be an instance of the adapter.');
  assert.true(instance instanceof ioredis, 'And as the class extends from the library, the instance is an instance of the library as well.');
  assert.true((0, _typeof2.default)(instance._options) === 'object', 'The instance will have an options object.');
  assert.true((0, _isArray.default)(instance._notReadyCommandsQueue), 'The instance will have an array as the _notReadyCommandsQueue property.');
  assert.true(instance._runningCommands instanceof _set.default, 'The instance will have a set as the _runningCommands property.');
  assert.end();
});
(0, _tapeCatch.default)('STORAGE Redis Adapter / ioredis constructor params and static method _defineLibrarySettings', function (assert) {
  var redisUrl = 'redis://localhost:6379/0';
  var redisParams = {
    host: 'fake_host',
    port: '6355',
    'db': 5,
    pass: 'fake_pass'
  };
  new RedisAdapter({
    url: redisUrl,
    connectionTimeout: 123,
    operationTimeout: 124
  }); // Keep in mind we're storing the arguments object, not a true array.

  assert.equal(constructorParams.length, 2, 'In this signature, the constructor receives two params.');
  assert.equal(constructorParams[0], redisUrl, 'When we use the Redis URL, that should be the first parameter passed to ioredis constructor');
  assert.deepEqual(constructorParams[1], {
    enableOfflineQueue: false,
    connectTimeout: 10000,
    lazyConnect: false
  }, 'and the second parameter would be the default settings for the lib.');
  new RedisAdapter(_objectSpread({}, redisParams, {
    connectionTimeout: 123,
    operationTimeout: 124
  }));
  assert.equal(constructorParams.length, 1, 'In this signature, the constructor receives one param.'); // we keep "pass" instead of "password" on our settings API to be backwards compatible.

  assert.deepEqual(constructorParams[0], {
    host: redisParams.host,
    port: redisParams.port,
    db: redisParams.db,
    password: redisParams.pass,
    enableOfflineQueue: false,
    connectTimeout: 10000,
    lazyConnect: false
  }, 'If we send all the redis params separate, it will pass one object to the library containing that and the rest of the options.');
  new RedisAdapter(_objectSpread({}, redisParams, {
    url: redisUrl,
    connectionTimeout: 123,
    operationTimeout: 124
  }));
  assert.equal(constructorParams.length, 2, 'In this signature, the constructor receives two params.');
  assert.equal(constructorParams[0], redisUrl, 'When we use the Redis URL, even if we specified all the other params one by one the URL takes precedence, so that should be the first parameter passed to ioredis constructor');
  assert.deepEqual(constructorParams[1], {
    enableOfflineQueue: false,
    connectTimeout: 10000,
    lazyConnect: false
  }, 'and the second parameter would be the default settings for the lib.');
  assert.end();
});
(0, _tapeCatch.default)('STORAGE Redis Adapter / static method - _defineOptions', function (assert) {
  var defaultOptions = {
    connectionTimeout: 10000,
    operationTimeout: 5000
  };
  assert.deepEqual(RedisAdapter._defineOptions({}), defaultOptions, 'We get the default options if we use an empty object.');
  assert.deepEqual(RedisAdapter._defineOptions({
    url: 'redis_url'
  }), {
    connectionTimeout: 10000,
    operationTimeout: 5000,
    url: 'redis_url'
  }, 'We get the merge of the provided and the default options.');
  var opts = {
    host: 'host',
    port: 'port',
    db: 'db',
    pass: 'pass'
  };
  assert.notEqual(RedisAdapter._defineOptions(opts), opts, 'Provided options are not mutated.');
  assert.deepEqual(opts, {
    host: 'host',
    port: 'port',
    db: 'db',
    pass: 'pass'
  }, 'Provided options are not mutated.');
  assert.deepEqual(RedisAdapter._defineOptions(opts), (0, _merge.default)({}, defaultOptions, opts), 'We get the merge of the provided and the default options.');
  assert.deepEqual(RedisAdapter._defineOptions({
    random: 1,
    crap: 'I do not think I can make it',
    secret: 'shh',
    url: 'I will make it'
  }), (0, _merge.default)({}, defaultOptions, {
    url: 'I will make it'
  }), 'Unwanted options will be skipped.');
  assert.end();
});
(0, _tapeCatch.default)('STORAGE Redis Adapter / instance methods - _listenToEvents', function (assert) {
  // Reset all stubs
  _sinon.default.resetHistory();

  assert.false(ioredisMock.once.called, 'Control assertion');
  assert.false(ioredisMock[METHODS_TO_PROMISE_WRAP[0]].called, 'Control assertion');
  var instance = new RedisAdapter({
    url: 'redis://localhost:6379/0'
  });
  assert.true(ioredisMock.once.calledTwice, 'If the method was called, it should have called the `once` function twice. If that it the case we can assume that the method was called on creation.'); // Reset stubs again, we'll check the behaviour calling the method directly.

  _sinon.default.resetHistory();

  assert.false(ioredisMock.once.called, 'Control assertion');
  assert.false(ioredisMock[METHODS_TO_PROMISE_WRAP[METHODS_TO_PROMISE_WRAP.length - 1]].called, 'Control assertion');

  instance._listenToEvents();

  assert.true(ioredisMock.once.calledTwice, 'The "once" method of the instance should be called twice.');
  var firstCall = ioredisMock.once.getCall(0);
  assert.equal(firstCall.args[0], 'ready', 'First argument for the first call should be the "ready" event.');
  assert.equal((0, _typeof2.default)(firstCall.args[1]), 'function', 'second argument for the first call should be a callback function.');
  var secondCall = ioredisMock.once.getCall(1);
  assert.equal(secondCall.args[0], 'close', 'First argument for the first call should be the "close" event.');
  assert.equal((0, _typeof2.default)(secondCall.args[1]), 'function', 'second argument for the first call should be a callback function.');
  assert.false(loggerMock.warn.called, 'Control assertion');
  secondCall.args[1](); // Execute the callback for "close"

  assert.true(loggerMock.info.calledOnce, 'The callback for the "close" event will only log info to the user about what is going on.');
  assert.true(loggerMock.info.calledWithExactly('Redis connection closed.'), 'The callback for the "close" event will only log info to the user about what is going on.');
  loggerMock.info.resetHistory();
  assert.false(loggerMock.info.called, 'Control assertion');
  assert.true((0, _isArray.default)(instance._notReadyCommandsQueue), 'Control assertion'); // Without any offline commands queued, execute the callback for "ready"

  firstCall.args[1]();
  assert.true(loggerMock.info.called, 'The callback for the "ready" event will inform the user about the trigger.');
  assert.true(loggerMock.info.calledWithExactly('Redis connection established. Queued commands: 0.'), 'The callback for the "ready" event will inform the user about the trigger.');
  assert.equal(instance._notReadyCommandsQueue, false, 'After the DB is ready, it will clean up the offline commands queue so we do not queue commands anymore.'); // Don't do this at home

  var queuedGetCommand = {
    command: _sinon.default.stub().resolves(),
    name: 'GET',
    resolve: _sinon.default.stub(),
    reject: _sinon.default.stub()
  };
  var queuedSetCommand = {
    command: _sinon.default.stub().rejects(),
    name: 'SET',
    resolve: _sinon.default.stub(),
    reject: _sinon.default.stub()
  };
  instance._notReadyCommandsQueue = [queuedGetCommand, queuedSetCommand];
  loggerMock.info.resetHistory(); // execute the callback for "ready" once more

  firstCall.args[1]();
  assert.true(loggerMock.info.calledThrice, 'If we had queued commands, it will log the event (1 call) as well as each executed command (n calls).');
  assert.true(loggerMock.info.calledWithExactly('Redis connection established. Queued commands: 2.'), 'The callback for the "ready" event will inform the user about the trigger and the amount of queued commands.');
  assert.true(loggerMock.info.calledWithExactly('Executing queued GET command.'), 'If we had queued, it will log the event as well as each executed command.');
  assert.true(loggerMock.info.calledWithExactly('Executing queued SET command.'), 'If we had queued commands, it will log the event as well as each executed command.');
  assert.true(queuedGetCommand.command.calledOnce, 'It will execute each queued command.');
  assert.true(queuedSetCommand.command.calledOnce, 'It will execute each queued command.');
  (0, _setTimeout2.default)(function () {
    // Remember this is tied to a promise.
    assert.true(queuedGetCommand.resolve.called, 'And depending on what happens with the command promise, it will call the resolve or reject function for the promise wrapper.');
    assert.false(queuedGetCommand.reject.called, 'And depending on what happens with the command promise, it will call the resolve or reject function for the promise wrapper.');
    assert.true(queuedSetCommand.reject.called, 'And depending on what happens with the command promise, it will call the resolve or reject function for the promise wrapper.');
    assert.false(queuedSetCommand.resolve.called, 'And depending on what happens with the command promise, it will call the resolve or reject function for the promise wrapper.');
    assert.end();
  }, 5);
});
(0, _tapeCatch.default)('STORAGE Redis Adapter / instance methods - _setTimeoutWrappers and queueing commands 1/2 - Error path', function (assert) {
  _sinon.default.resetHistory();

  var instance = new RedisAdapter({
    url: 'redis://localhost:6379/0'
  });
  (0, _forEach2.default)(METHODS_TO_PROMISE_WRAP, function (methodName) {
    assert.notEqual(instance[methodName], ioredisMock[methodName], "Method \"".concat(methodName, "\" from redis library should be wrapped."));
    assert.false(instance[methodName].called || ioredisMock[methodName].called, 'Checking that neither the method nor the wrapper were called yet.');
    var startingQueueLength = instance._notReadyCommandsQueue.length; // We do have the commands queue on this state, so a call for this methods will queue the command.

    var wrapperResult = instance[methodName](methodName);
    assert.true(wrapperResult instanceof _promise.default, 'The result is a promise since we are queueing commands on this state.');
    assert.equal(instance._notReadyCommandsQueue.length, startingQueueLength + 1, 'The queue should have one more item.');
    var queuedCommand = instance._notReadyCommandsQueue[0];
    assert.equal((0, _typeof2.default)(queuedCommand.resolve), 'function', 'The queued item should have the correct form.');
    assert.equal((0, _typeof2.default)(queuedCommand.reject), 'function', 'The queued item should have the correct form.');
    assert.equal((0, _typeof2.default)(queuedCommand.command), 'function', 'The queued item should have the correct form.');
    assert.equal(queuedCommand.name, methodName.toUpperCase(), 'The queued item should have the correct form.');
  });
  instance._notReadyCommandsQueue = false; // Remove the queue.

  loggerMock.error.resetHistory;
  (0, _forEach2.default)(METHODS_TO_PROMISE_WRAP, function (methodName) {
    // We do NOT have the commands queue on this state, so a call for this methods will execute the command.
    assert.false(ioredisMock[methodName].called, "Control assertion - Original method (".concat(methodName, ") was not yet called"));
    var previousTimeoutCalls = timeout.callCount;
    var previousRunningCommandsSize = instance._runningCommands.size;
    instance[methodName](methodName).catch(function () {}); // Swallow exception so it's not spread to logs.

    assert.true(ioredisMock[methodName].called, "Original method (".concat(methodName, ") is called right away (through wrapper) when we are not queueing anymore."));
    assert.equal(instance._runningCommands.size, previousRunningCommandsSize + 1, 'If the result of the operation was a thenable it will add the item to the running commands queue.');
    assert.equal(timeout.callCount, previousTimeoutCalls + 1, 'The promise returned by the original method should have a timeout wrapper.'); // Get the original promise (the one passed to timeout)

    var commandTimeoutResolver = timeoutPromiseResolvers[0];
    assert.true(timeout.calledWithExactly(5000, commandTimeoutResolver.originalPromise), 'Timeout function should have received the correct ms amount and the right promise.');
    assert.true(instance._runningCommands.has(commandTimeoutResolver.originalPromise), 'Correct promise should be the one on the _runningCommands queue.');
    commandTimeoutResolver.rej('test');
    (0, _setTimeout2.default)(function () {
      // Allow the promises to tick.
      assert.false(instance._runningCommands.has(commandTimeoutResolver.originalPromise), 'After a command finishes with error, it\'s promise is removed from the instance._runningCommands queue.');
      assert.true(loggerMock.error.calledWithExactly("".concat(methodName, " operation threw an error or exceeded configured timeout of 5000ms. Message: test")), 'The log error method should be called with the corresponding messages, depending on the method, error and operationTimeout.');
    }, 0);
  });
  (0, _setTimeout2.default)(function () {
    assert.end();
  }, 200);
});
(0, _tapeCatch.default)('STORAGE Redis Adapter / instance methods - _setTimeoutWrappers and queueing commands 2/2 - Success path', function (assert) {
  _sinon.default.resetHistory();

  var instance = new RedisAdapter({
    url: 'redis://localhost:6379/0'
  });
  instance._notReadyCommandsQueue = false; // Connection is "ready"

  (0, _forEach2.default)(METHODS_TO_PROMISE_WRAP, function (methodName) {
    // Just call the wrapped method, we don't care about all the paths tested on the previous case, just how it behaves when the command is resolved.
    instance[methodName](methodName); // Get the original promise (the one passed to timeout)

    var commandTimeoutResolver = timeoutPromiseResolvers[0];
    commandTimeoutResolver.res('test');
    (0, _setTimeout2.default)(function () {
      // Allow the promises to tick.
      assert.false(loggerMock.error.called, 'No error should be logged');
      assert.false(instance._runningCommands.has(commandTimeoutResolver.originalPromise), 'After a command finishes successfully, it\'s promise is removed from the instance._runningCommands queue.');
    }, 0);
  });
  (0, _setTimeout2.default)(function () {
    assert.end();
  }, 200);
});
(0, _tapeCatch.default)('STORAGE Redis Adapter / instance methods - _setDisconnectWrapper', function (assert) {
  _sinon.default.resetHistory();

  var instance = new RedisAdapter({
    url: 'redis://localhost:6379/0'
  });
  assert.notEqual(instance.disconnect, ioredisMock.disconnect, 'disconnect() method from redis library should be wrapped.'); // Call the method.
  // Note that there are no commands on the queue for this first run.

  instance.disconnect();
  assert.false(ioredisMock.disconnect.called, 'Original method should not be called right away.');
  (0, _setTimeout2.default)(function () {
    // o queued commands timeout wrapper.
    assert.true(loggerMock.debug.calledOnceWithExactly('No commands pending execution, disconnect.'));
    assert.true(ioredisMock.disconnect.calledOnce, 'Original method should have been called once, asynchronously');
    loggerMock.debug.resetHistory();
    ioredisMock.disconnect.resetHistory(); // Second run, two pending commands, one will fail.

    instance._runningCommands.add(_promise.default.resolve());

    instance.disconnect();

    var rejectedPromise = _promise.default.reject('test-error');

    instance._runningCommands.add(rejectedPromise);

    rejectedPromise.catch(function () {}); // Swallow the unhandled to avoid unhandledRejection warns

    (0, _setTimeout2.default)(function () {
      var _context2;

      // queued with rejection timeout wrapper
      assert.true(loggerMock.info.calledOnceWithExactly('Attempting to disconnect but there are 2 commands still waiting for resolution. Defering disconnection until those finish.'));

      _promise.default.all((0, _values.default)(_context2 = instance._runningCommands).call(_context2)).catch(function (e) {
        (0, _setImmediate2.default)(function () {
          // Allow the callback to execute before checking.
          assert.true(loggerMock.warn.calledWithExactly("Pending commands finished with error: ".concat(e, ". Proceeding with disconnection.")), 'Should warn about the error but tell user that will disconnect anyways.');
          assert.true(ioredisMock.disconnect.calledOnce, 'Original method should have been called once, asynchronously');
          loggerMock.info.resetHistory();
          loggerMock.warn.resetHistory();
          ioredisMock.disconnect.resetHistory(); // Third run, pending commands all successful

          instance._runningCommands.clear();

          instance._runningCommands.add(_promise.default.resolve());

          instance._runningCommands.add(_promise.default.resolve());

          instance.disconnect();

          instance._runningCommands.add(_promise.default.resolve());

          instance._runningCommands.add(_promise.default.resolve());

          (0, _setTimeout2.default)(function () {
            var _context3;

            assert.true(loggerMock.info.calledOnceWithExactly('Attempting to disconnect but there are 4 commands still waiting for resolution. Defering disconnection until those finish.'));

            _promise.default.all((0, _values.default)(_context3 = instance._runningCommands).call(_context3)).then(function () {
              // This one will go through success path
              (0, _setImmediate2.default)(function () {
                assert.true(loggerMock.debug.calledOnceWithExactly('Pending commands finished successfully, disconnecting.'));
                assert.true(ioredisMock.disconnect.calledOnce, 'Original method should have been called once, asynchronously');
              });
            });
          }, 10);
        });
      });
    }, 10);
  }, 10);
  (0, _setTimeout2.default)(function () {
    assert.end();
  }, 400);
});