"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/keys"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/get-iterator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _lang = require("../../utils/lang");

var _usesSegments = _interopRequireDefault(require("../../utils/splits/usesSegments"));

var SplitCacheInMemory =
/*#__PURE__*/
function () {
  function SplitCacheInMemory() {
    (0, _classCallCheck2.default)(this, SplitCacheInMemory);
    this.flush();
  }

  (0, _createClass2.default)(SplitCacheInMemory, [{
    key: "addSplit",
    value: function addSplit(splitName, split) {
      var splitFromMemory = this.getSplit(splitName);

      if (splitFromMemory) {
        // We had this Split already
        var previousSplit = JSON.parse(splitFromMemory);

        if (previousSplit.trafficTypeName) {
          var previousTtName = previousSplit.trafficTypeName;
          this.ttCache[previousTtName]--;
          if (!this.ttCache[previousTtName]) delete this.ttCache[previousTtName];
        }

        if ((0, _usesSegments.default)(previousSplit.conditions)) {
          // Substract from segments count for the previous version of this Split.
          this.splitsWithSegmentsCount--;
        }
      }

      var parsedSplit = JSON.parse(split);

      if (parsedSplit) {
        // Store the Split.
        this.splitCache.set(splitName, split); // Update TT cache

        var ttName = parsedSplit.trafficTypeName;

        if (ttName) {
          // safeguard
          if (!this.ttCache[ttName]) this.ttCache[ttName] = 0;
          this.ttCache[ttName]++;
        } // Add to segments count for the new version of the Split


        if ((0, _usesSegments.default)(parsedSplit.conditions)) this.splitsWithSegmentsCount++;
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var results = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          results.push(this.addSplit(key, value));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    }
  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      var split = this.getSplit(splitName);

      if (split) {
        // Delete the Split
        this.splitCache.delete(splitName);
        var parsedSplit = JSON.parse(split);
        var ttName = parsedSplit.trafficTypeName;

        if (ttName) {
          // safeguard
          this.ttCache[ttName]--; // Update tt cache

          if (!this.ttCache[ttName]) delete this.ttCache[ttName];
        } // Update the segments count.


        if ((0, _usesSegments.default)(parsedSplit.conditions)) this.splitsWithSegmentsCount--;
        return 1;
      } else {
        return 0;
      }
    }
  }, {
    key: "removeSplits",
    value: function removeSplits(splitNames) {
      var _this = this;

      (0, _forEach.default)(splitNames).call(splitNames, function (n) {
        return _this.removeSplit(n);
      });
      return splitNames.length;
    }
  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      return this.splitCache.get(splitName);
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      this.changeNumber = changeNumber;
      return true;
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      return this.changeNumber;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var _context;

      return (0, _toConsumableArray2.default)((0, _values.default)(_context = this.splitCache).call(_context));
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var _context2;

      return (0, _toConsumableArray2.default)((0, _keys.default)(_context2 = this.splitCache).call(_context2));
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      return (0, _lang.isFinite)(this.ttCache[trafficType]) && this.ttCache[trafficType] > 0;
    }
  }, {
    key: "usesSegments",
    value: function usesSegments() {
      return this.getChangeNumber() === -1 || this.splitsWithSegmentsCount > 0;
    }
  }, {
    key: "flush",
    value: function flush() {
      this.splitCache = new _map.default();
      this.ttCache = {};
      this.changeNumber = -1;
      this.splitsWithSegmentsCount = 0;
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this2 = this;

      var splits = new _map.default();
      (0, _forEach.default)(splitNames).call(splitNames, function (splitName) {
        splits.set(splitName, _this2.splitCache.get(splitName) || null);
      });
      return splits;
    }
    /**
     * Check if the splits information is already stored in cache. In memory there is no cache to check.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return false;
    }
  }]);
  return SplitCacheInMemory;
}();

var _default = SplitCacheInMemory;
exports.default = _default;