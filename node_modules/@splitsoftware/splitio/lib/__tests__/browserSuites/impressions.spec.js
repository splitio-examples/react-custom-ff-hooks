"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = _default;

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/some"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("../mocks/splitchanges.since.1457552620999.json"));

var _mysegmentsFacundoSplitIo = _interopRequireDefault(require("../mocks/mysegments.facundo@split.io.json"));

var baseUrls = {
  sdk: 'https://sdk.baseurl/impressionsSuite',
  events: 'https://events.baseurl/impressionsSuite'
};
var settings = (0, _settings.default)({
  core: {
    key: 'asd'
  },
  urls: baseUrls
});

function _default(mock, assert) {
  // Mocking this specific route to make sure we only get the items we want to test from the handlers.
  mock.onGet(settings.url('/splitChanges?since=-1')).replyOnce(200, _splitchangesSince.default);
  mock.onGet(settings.url('/splitChanges?since=1457552620999')).reply(200, _splitchangesSince2.default);
  mock.onGet(settings.url('/mySegments/facundo@split.io')).reply(200, _mysegmentsFacundoSplitIo.default);
  var splitio = (0, _.SplitFactory)({
    core: {
      authorizationKey: '<some-token>',
      key: 'facundo@split.io'
    },
    scheduler: {
      featuresRefreshRate: 0.5,
      segmentsRefreshRate: 0.5,
      metricsRefreshRate: 3000,
      impressionsRefreshRate: 0.5
    },
    startup: {
      eventsFirstPushWindow: 3000
    },
    urls: baseUrls
  });
  var client = splitio.client();

  var assertPayload = function assertPayload(req) {
    var resp = JSON.parse(req.data);
    assert.equal(resp.length, 2, 'We performed two evaluations so we should have 2 impressions');
    var dependencyChildImpr = (0, _filter.default)(resp).call(resp, function (e) {
      return e.testName === 'hierarchical_splits_test';
    })[0];
    var alwaysOnWithConfigImpr = (0, _filter.default)(resp).call(resp, function (e) {
      return e.testName === 'split_with_config';
    })[0];
    assert.true(dependencyChildImpr, 'Split we wanted to evaluate should be present on the impressions.');
    assert.false((0, _some.default)(resp).call(resp, function (e) {
      return e.testName === 'hierarchical_dep_always_on';
    }), 'Parent split evaluations should not result in impressions.');
    assert.false((0, _some.default)(resp).call(resp, function (e) {
      return e.testName === 'hierarchical_dep_hierarchical';
    }), 'No matter how deep is the chain.');
    assert.true(alwaysOnWithConfigImpr, 'Split evaluated with config should have generated an impression too.');
    assert.false(Object.prototype.hasOwnProperty.call(alwaysOnWithConfigImpr.keyImpressions[0], 'configuration'), 'Impressions do not change with configuration evaluations.');
    assert.false(Object.prototype.hasOwnProperty.call(alwaysOnWithConfigImpr.keyImpressions[0], 'config'), 'Impressions do not change with configuration evaluations.');
    var _dependencyChildImpr$ = dependencyChildImpr.keyImpressions[0],
        keyName = _dependencyChildImpr$.keyName,
        label = _dependencyChildImpr$.label,
        treatment = _dependencyChildImpr$.treatment;
    assert.equal(keyName, 'facundo@split.io', 'Present impression should have the correct key.'); // The label present on the mock.

    assert.equal(label, 'expected label', 'Present impression should have the correct label.');
    assert.equal(treatment, 'on', 'Present impression should have the correct treatment.');
  };

  mock.onPost(settings.url('/testImpressions/bulk')).replyOnce(function (req) {
    assertPayload(req);
    assert.comment('After a failure, Impressions will keep the data for the next call.');
    return [400];
  }) // Attach again to catch the retry.
  .onPost(settings.url('/testImpressions/bulk')).replyOnce(function (req) {
    assert.comment('We do one retry, so after a failed impressions post we will try once more.');
    assertPayload(req);
    client.destroy();
    assert.end();
    return [200];
  });
  client.ready().then(function () {
    // depends on hierarchical_dep_hierarchical which depends on hierarchical_dep_always_on
    assert.equal(client.getTreatment('hierarchical_splits_test'), 'on', 'We should get an evaluation as always.');
    assert.deepEqual(client.getTreatmentWithConfig('split_with_config'), {
      treatment: 'on',
      config: '{"color":"brown","dimensions":{"height":12,"width":14},"text":{"inner":"click me"}}'
    }, 'We should get an evaluation as always.');
  });
}