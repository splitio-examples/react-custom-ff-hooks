"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.default = _default;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/date/now"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _ = require("../../");

var _splitchangesSince = _interopRequireDefault(require("../mocks/splitchanges.since.-1.json"));

var _splitchangesSince2 = _interopRequireDefault(require("../mocks/splitchanges.since.1457552620999.json"));

var _mysegmentsNicolasSplitIo = _interopRequireDefault(require("../mocks/mysegments.nicolas@split.io.json"));

var _splitchangesReal = _interopRequireDefault(require("../mocks/splitchanges.real.json"));

var _splitchangesRealUpdateWithSegments = _interopRequireDefault(require("../mocks/splitchanges.real.updateWithSegments.json"));

var _splitchangesRealUpdateWithoutSegments = _interopRequireDefault(require("../mocks/splitchanges.real.updateWithoutSegments.json"));

var _splitchangesRealWithSegments = _interopRequireDefault(require("../mocks/splitchanges.real.withSegments.json"));

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; (0, _forEach.default)(_context = ownKeys(Object(source), true)).call(_context, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context2; (0, _forEach.default)(_context2 = ownKeys(Object(source))).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

var baseConfig = {
  core: {
    authorizationKey: '<fake-token-3>',
    key: 'nicolas@split.io'
  },
  scheduler: {
    featuresRefreshRate: 3000,
    segmentsRefreshRate: 3000,
    metricsRefreshRate: 3000,
    impressionsRefreshRate: 3000
  },
  startup: {
    eventsFirstPushWindow: 3000 // We use default for the readiness related ones.

  }
};

function _default(mock, assert) {
  assert.test(function (t) {
    // Timeout test, we have retries but splitChanges takes too long
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessSuite1',
      events: 'https://events.baseurl/readinessSuite1'
    };
    mock.onGet(testUrls.sdk + '/splitChanges?since=-1').reply(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _splitchangesSince.default, {}]);
        }, 5100);
      });
    }).onGet(testUrls.sdk + '/mySegments/nicolas@split.io').reply(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _mysegmentsNicolasSplitIo.default, {}]);
        }, 4900);
      });
    }).onGet(testUrls.sdk + '/splitChanges?since=1457552620999').reply(200, _splitchangesSince2.default);
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      urls: testUrls
    }));
    var client = splitio.client();
    client.once(client.Event.SDK_READY, function () {
      t.fail('### IS READY - NOT TIMED OUT when it should.');
      t.end();
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.pass('### SDK TIMED OUT - Requests took longer than we allowed per requestTimeoutBeforeReady on both attempts, timed out.');
      client.destroy().then(function () {
        t.end();
      });
    });
  });
  assert.test(function (t) {
    // Timeout test, we have retries but mySegmnets takes too long
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessSuite2',
      events: 'https://events.baseurl/readinessSuite2'
    };
    mock.onGet(testUrls.sdk + '/splitChanges?since=-1').reply(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _splitchangesSince.default, {}]);
        }, 4900);
      });
    }).onGet(testUrls.sdk + '/mySegments/nicolas@split.io').reply(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _mysegmentsNicolasSplitIo.default, {}]);
        }, 5100);
      });
    }).onGet(testUrls.sdk + '/splitChanges?since=1457552620999').reply(200, _splitchangesSince2.default);
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      urls: testUrls
    }));
    var client = splitio.client();
    client.once(client.Event.SDK_READY, function () {
      t.fail('### IS READY - NOT TIMED OUT when it should.');
      t.end();
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.pass('### SDK TIMED OUT - Requests took longer than we allowed per requestTimeoutBeforeReady on both attempts, timed out.');
      client.destroy().then(function () {
        t.end();
      });
    });
  });
  assert.test(function (t) {
    // Readiness test, first splitChanges above the limit (req timeout) second one below so final state should be ready.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessSuite3',
      events: 'https://events.baseurl/readinessSuite3'
    };
    mock.onGet(testUrls.sdk + '/splitChanges?since=-1').replyOnce(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _splitchangesSince.default, {}]);
        }, 5100);
      });
    }).onGet(testUrls.sdk + '/splitChanges?since=-1').replyOnce(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _splitchangesSince.default, {}]);
        }, 4900);
      }); // Faster, it should get ready on the retry.
    }).onGet(testUrls.sdk + '/mySegments/nicolas@split.io').reply(function () {
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, _mysegmentsNicolasSplitIo.default, {}]);
        }, 4900);
      });
    }).onGet(testUrls.sdk + '/splitChanges?since=1457552620999').reply(200, _splitchangesSince2.default);
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      urls: testUrls
    }));
    var client = splitio.client();
    client.once(client.Event.SDK_READY, function () {
      t.pass('### SDK IS READY as it should, both requests are under the limits');
      client.destroy().then(function () {
        t.end();
      });
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not in this scenario');
      t.end();
    });
  });
  /************** Now we will validate the intelligent mySegments pausing, which requires lots of code. Related code below. **************/

  localStorage.clear();
  var mySegmentsEndpointDelay = 450;

  function mockForSegmentsPauseTest(testUrls) {
    var startWithSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var mySegmentsHits = 0;
    mock.onGet(new RegExp("".concat(testUrls.sdk, "/mySegments/nicolas\\d?@split.io"))).reply(function () {
      // Mock any mySegments call, so we can test with multiple clients.
      mySegmentsHits++;
      return new _promise.default(function (res) {
        (0, _setTimeout2.default)(function () {
          res([200, {
            mySegments: []
          }, {}]);
        }, mySegmentsEndpointDelay);
      });
    }) // Now mock the no more updates state 
    .onGet(testUrls.sdk + '/splitChanges?since=1457552669999').reply(200, {
      splits: [],
      since: 1457552669999,
      till: 1457552669999
    });

    if (startWithSegments) {
      // Adjust since and till so the order is inverted.
      mock.onGet(testUrls.sdk + '/splitChanges?since=-1').reply(200, _splitchangesRealWithSegments.default).onGet(testUrls.sdk + '/splitChanges?since=1457552620999').reply(200, _objectSpread({}, _splitchangesRealUpdateWithoutSegments.default, {
        since: 1457552620999,
        till: 1457552649999
      })).onGet(testUrls.sdk + '/splitChanges?since=1457552649999').reply(200, _objectSpread({}, _splitchangesRealUpdateWithSegments.default, {
        since: 1457552649999,
        till: 1457552669999
      }));
    } else {
      mock.onGet(testUrls.sdk + '/splitChanges?since=-1').reply(200, _splitchangesReal.default).onGet(testUrls.sdk + '/splitChanges?since=1457552620999').reply(200, _splitchangesRealUpdateWithSegments.default).onGet(testUrls.sdk + '/splitChanges?since=1457552649999').reply(200, _splitchangesRealUpdateWithoutSegments.default);
    }

    return function () {
      return mySegmentsHits;
    };
  }

  assert.test(function (t) {
    // Testing how the SDK pauses/resumes segments synchronization.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessMySegmentsSuite',
      events: 'https://events.baseurl/readinessMySegmentsSuite'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, false);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start < 50, 'It should be ready really quickly, without waiting for mySegments, as there were no segments in the first splits payload.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 1 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt, but it stopped syncing afterwards.');
      }, 2500); // Now we will wait until it picks up Splits, using the SDK_UPDATE event. Features are refreshed every 3s, but segments every 1s. 

      client.once(client.Event.SDK_UPDATE, function () {
        // This update came with segments, it should have tried to fetch mySegments for all used keys.
        (0, _setTimeout2.default)(function () {
          t.equal(getMySegmentsHits(), 2 * CLIENTS_COUNT, 'It should have tried to synchronize mySegments as soon as it received a new Split with segments.');
        }, 0);
        (0, _setTimeout2.default)(function () {
          // Nasty ugly crap to avoid listening to the update coming from mySegment calls.
          client.once(client.Event.SDK_UPDATE, function () {
            (0, _setTimeout2.default)(function () {
              // This update left us in an state with no segments (removed the matcher we fetched on the previous one), it should stop the producer and not trigger more requests.
              t.equal(getMySegmentsHits(), 4 * CLIENTS_COUNT, 'It should have tried to synchronize mySegments periodically.');
              (0, _setTimeout2.default)(function () {
                t.equal(getMySegmentsHits(), 4 * CLIENTS_COUNT, 'It should have not tried to synchronize segments again after the last update that left us in a no segment state.');

                _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
                  t.end();
                });
              }, 10000);
            }, 0);
          });
        }, 3000);
      });
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing how the SDK pauses/resumes segments synchronization in localstorage.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, false);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'not_using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start < 50, 'It should be ready really quickly, without waiting for mySegments, as there were no segments in the first splits payload.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 1 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt, but it stopped syncing afterwards.');
      }, 2500); // Now we will wait until it picks up Splits, using the SDK_UPDATE event. Features are refreshed every 3s, but segments every 1s. 

      client.once(client.Event.SDK_UPDATE, function () {
        // This update came with segments, it should have tried to fetch mySegments for all used keys.
        (0, _setTimeout2.default)(function () {
          t.equal(getMySegmentsHits(), 2 * CLIENTS_COUNT, 'It should have tried to synchronize mySegments as soon as it received a new Split with segments.');
        }, 0);
        (0, _setTimeout2.default)(function () {
          // Nasty ugly crap to avoid listening to the update coming from mySegment calls.
          client.once(client.Event.SDK_UPDATE, function () {
            (0, _setTimeout2.default)(function () {
              // This update left us in an state with no segments (removed the matcher we fetched on the previous one), it should stop the producer and not trigger more requests.
              t.equal(getMySegmentsHits(), 4 * CLIENTS_COUNT, 'It should have tried to synchronize mySegments periodically.');
              (0, _setTimeout2.default)(function () {
                t.equal(getMySegmentsHits(), 4 * CLIENTS_COUNT, 'It should have not tried to synchronize segments again after the last update that left us in a no segment state.');

                _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
                  t.end();
                });
              }, 10000);
            }, 0);
          });
        }, 3000);
      });
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing how the SDK pauses/resumes segments synchronization.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessMySegmentsSuite2',
      events: 'https://events.baseurl/readinessMySegmentsSuite2'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, true);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start >= mySegmentsEndpointDelay, 'It should not be ready without waiting for mySegments, as there are segments in the first splits payload.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt and keep syncing afterwards.');
      }, 2500); // Now we will wait until it picks up splits, using the SDK_UPDATE event. Features are refreshed every 3s, but segments every 1s (plus sync time). 

      client.once(client.Event.SDK_UPDATE, function () {
        // This update came without segments, it should not trigger an extra fetch.
        (0, _setTimeout2.default)(function () {
          t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'It should have stopped synchronizing mySegments since it transitioned to no segments state.');
        }, 0);
        (0, _setTimeout2.default)(function () {
          client.once(client.Event.SDK_UPDATE, function () {
            (0, _setTimeout2.default)(function () {
              // This update left us in an state with segments again, it should trigger a request ASAP and restart the producer.
              t.equal(getMySegmentsHits(), 4 * CLIENTS_COUNT, 'It should have tried to synchronize mySegments periodically.');
              (0, _setTimeout2.default)(function () {
                t.equal(getMySegmentsHits(), 6 * CLIENTS_COUNT, 'It should keep the producer synchronizing periodically..');

                _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
                  t.end();
                });
              }, 3000);
            }, 0);
          });
        }, 3000);
      });
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing when we start from scratch
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite2',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite2'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, true);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start >= mySegmentsEndpointDelay, 'It should not be ready without waiting for mySegments, as there are segments in the first splits payload.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt and keep syncing afterwards.');
      }, 2500); // Now we will wait until it picks up splits, using the SDK_UPDATE event. Features are refreshed every 3s, but segments every 1s (plus sync time). 

      client.once(client.Event.SDK_UPDATE, function () {
        // This update came without segments, it should not trigger an extra fetch.
        (0, _setTimeout2.default)(function () {
          t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'It should have stopped synchronizing mySegments since it transitioned to no segments state.');
        }, 0);
        (0, _setTimeout2.default)(function () {
          client.once(client.Event.SDK_UPDATE, function () {
            (0, _setTimeout2.default)(function () {
              // This update left us in an state with segments again, it should trigger a request ASAP and restart the producer.
              t.equal(getMySegmentsHits(), 4 * CLIENTS_COUNT, 'It should have tried to synchronize mySegments periodically.');
              (0, _setTimeout2.default)(function () {
                t.equal(getMySegmentsHits(), 6 * CLIENTS_COUNT, 'It should keep the producer synchronizing periodically..');

                _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
                  t.end();
                });
              }, 3000);
            }, 0);
          });
        }, 3000);
      });
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing when we start from scratch with segments being previously used
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite3',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite3'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, true);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start >= mySegmentsEndpointDelay, 'It should not be ready without waiting for mySegments, when we start from cache it might be stale.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt and keep syncing afterwards.');

        _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
          t.end();
        });
      }, 2500);
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing when we start from cache without segments being previously used, and first update has no segments.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite4',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite4'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, false);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'not_using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start < 50, 'It should be ready quickly, since it had no segments and update has no segments either.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 1 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt but stopped syncing afterwards');

        _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
          t.end();
        });
      }, 4500);
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing when we start from cache without segments being previously used, and first update HAS segments.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite4',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite4'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, false); // I'm having the first update of Splits come with segments. In this scenario it'll wait for mySegments to download before being ready.

    mock.onGet(testUrls.sdk + '/splitChanges?since=1457552669999').reply(200, _objectSpread({}, _splitchangesRealUpdateWithSegments.default, {
      since: 1457552669999,
      till: 1457552679999
    })).onGet(testUrls.sdk + '/splitChanges?since=1457552679999').reply(200, {
      splits: [],
      since: 1457552679999,
      till: 1457552679999
    });
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'not_using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start >= mySegmentsEndpointDelay, 'It should not be ready without waiting for mySegments, when we start from cache it might be stale.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt but stopped syncing afterwards');

        _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
          t.end();
        });
      }, 3000);
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing when we start from cache with segments being previously used, and update is empty.
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite5',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite5'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, false);
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start >= mySegmentsEndpointDelay, 'It should not be ready without waiting for mySegments, when we start from cache it might be stale and we had segments even though the update has nothing.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 3 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt and kept syncing afterwards');

        _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
          t.end();
        });
      }, 3000);
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
  assert.test(function (t) {
    // Testing when we start from cache with segments being previously used and first update removes segments
    var testUrls = {
      sdk: 'https://sdk.baseurl/readinessLSMySegmentsSuite5',
      events: 'https://events.baseurl/readinessLSMySegmentsSuite5'
    };
    var getMySegmentsHits = mockForSegmentsPauseTest(testUrls, false); // I'm having the first update of Splits come without segments. In this scenario it'll NOT wait for mySegments to download before being ready.

    mock.onGet(testUrls.sdk + '/splitChanges?since=1457552669999').reply(200, _objectSpread({}, _splitchangesRealUpdateWithoutSegments.default, {
      since: 1457552669999,
      till: 1457552679999
    })).onGet(testUrls.sdk + '/splitChanges?since=1457552679999').reply(200, {
      splits: [],
      since: 1457552679999,
      till: 1457552679999
    });
    var start = (0, _now.default)();
    var splitio = (0, _.SplitFactory)(_objectSpread({}, baseConfig, {
      startup: {
        retriesOnFailureBeforeReady: 0
      },
      scheduler: {
        featuresRefreshRate: 3.1,
        segmentsRefreshRate: 1,
        metricsRefreshRate: 3000,
        impressionsRefreshRate: 3000
      },
      storage: {
        type: 'LOCALSTORAGE',
        prefix: 'using_segments'
      },
      urls: testUrls
    }));
    var CLIENTS_COUNT = 3; // Just so it's easier to read the assertions.

    var client = splitio.client();
    var client2 = splitio.client('nicolas2@split.io');
    var client3 = splitio.client('nicolas3@split.io');
    client.once(client.Event.SDK_READY, function () {
      t.ok((0, _now.default)() - start < 50, 'It should be ready without waiting for mySegments, since when it downloads changes it will have no more use for them.');
      (0, _setTimeout2.default)(function () {
        t.equal(getMySegmentsHits(), 1 * CLIENTS_COUNT, 'mySegments should had been hit once per client on the first attempt and stopped syncing afterwards');

        _promise.default.all([client2.destroy(), client3.destroy(), client.destroy()]).then(function () {
          t.end();
        });
      }, 3000);
    });
    client.once(client.Event.SDK_READY_TIMED_OUT, function () {
      t.fail('### SDK TIMED OUT - It should not timeout in this scenario as segments were not necessary.');
      t.end();
    });
  });
}