"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.array.join");

require("core-js/modules/es.regexp.constructor");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.split");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _path = _interopRequireDefault(require("path"));

var _tapeCatch = _interopRequireDefault(require("tape-catch"));

var _sinon = _interopRequireDefault(require("sinon"));

var _axiosMockAdapter = _interopRequireDefault(require("axios-mock-adapter"));

var _ = require("../../");

var _settings = _interopRequireDefault(require("../../utils/settings"));

var _transport = require("../../services/transport");

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = (0, _filter.default)(symbols).call(symbols, function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; (0, _forEach.default)(_context = ownKeys(Object(source), true)).call(_context, function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { var _context2; (0, _forEach.default)(_context2 = ownKeys(Object(source))).call(_context2, function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

// Set the mock adapter on the current axios instance
var mock = new _axiosMockAdapter.default((0, _transport.__getAxiosInstance)());
var settings = (0, _settings.default)({
  core: {
    key: 'facundo@split.io'
  }
});

var spySplitChanges = _sinon.default.spy();

var spySegmentChanges = _sinon.default.spy();

var spyMySegments = _sinon.default.spy();

var spyEventsBulk = _sinon.default.spy();

var spyTestImpressionsBulk = _sinon.default.spy();

var spyMetricsTimes = _sinon.default.spy();

var spyMetricsCounters = _sinon.default.spy();

var spyAny = _sinon.default.spy(); // helper function that should call the spy function and return a 200 to keep
// going the axios request flow


var replySpy = function replySpy(spy) {
  spy();
  return [200];
};

var configMocks = function configMocks() {
  mock.onAny(new RegExp("".concat(settings.url('/splitChanges/'), ".*"))).reply(function () {
    return replySpy(spySplitChanges);
  }).onAny(new RegExp("".concat(settings.url('/segmentChanges/'), ".*"))).reply(function () {
    return replySpy(spySegmentChanges);
  }).onAny(new RegExp("".concat(settings.url('/mySegments/'), ".*"))).reply(function () {
    return replySpy(spyMySegments);
  }).onAny(settings.url('/events/bulk')).reply(function () {
    return replySpy(spyEventsBulk);
  }).onAny(settings.url('/testImpressions/bulk')).reply(function () {
    return replySpy(spyTestImpressionsBulk);
  }).onAny(settings.url('/metrics/times')).reply(function () {
    return replySpy(spyMetricsTimes);
  }).onAny(settings.url('/metrics/counters')).reply(function () {
    return replySpy(spyMetricsCounters);
  }).onAny().reply(function () {
    return replySpy(spyAny);
  });
};

var settingsGenerator = function settingsGenerator(mockFileName) {
  return {
    core: {
      authorizationKey: 'localhost'
    },
    scheduler: {
      impressionsRefreshRate: 0.01,
      eventsPushRate: 0.01,
      metricsRefreshRate: 0.01,
      offlineRefreshRate: 3
    },
    startup: {
      eventsFirstPushWindow: 0,
      readyTimeout: 3,
      retriesOnFailureBeforeReady: 0
    },
    features: _path.default.join(__dirname, mockFileName)
  };
};

(0, _tapeCatch.default)('NodeJS Offline Mode', function (t) {
  t.test('Old format evaluations - .split', DotSplitTests);
  t.test('New format evaluations - .yaml extension', (0, _bind.default)(DotYAMLTests).call(DotYAMLTests, null, 'split.yaml'));
  t.test('New format evaluations - .yml extension', (0, _bind.default)(DotYAMLTests).call(DotYAMLTests, null, 'split2.yml'));
  t.test('Old format manager - .split extension', ManagerDotSplitTests);
  t.test('New format manager - .yaml extension', (0, _bind.default)(ManagerDotYamlTests).call(ManagerDotYamlTests, null, 'split.yaml'));
  t.test('New format manager - .yml extension', (0, _bind.default)(ManagerDotYamlTests).call(ManagerDotYamlTests, null, 'split2.yml'));
  t.test('Trying to specify an invalid extension it will timeout', function (assert) {
    var config = settingsGenerator('.forbidden');

    _sinon.default.spy(console, 'log');

    var factory = (0, _.SplitFactory)(_objectSpread({}, config, {
      debug: 'ERROR'
    })); // enable error level logs to check the message.

    var client = factory.client();
    client.on(client.Event.SDK_READY, function () {
      assert.fail('If tried to load a file with invalid extension, we should not get SDK_READY.');
      client.destroy();
      assert.end();
    });
    client.on(client.Event.SDK_READY_TIMED_OUT, function () {
      assert.pass('If tried to load a file with invalid extension, we should emit SDK_READY_TIMED_OUT.');
      assert.ok(console.log.calledWithMatch("[ERROR] splitio-producer:offline => There was an issue loading the mock Splits data, no changes will be applied to the current cache. Invalid extension specified for Splits mock file. Accepted extensions are \".yml\" and \".yaml\". Your specified file is ".concat(config.features)));
      console.log.restore();
      client.destroy();
      assert.end();
    });
  });
});

function networkAssertions(client, assert) {
  return client.destroy().then(function () {
    // We test the breakdown instead of just the misc because it's faster to spot where the issue is
    assert.notOk(spySplitChanges.called, 'On offline mode we should not call the splitChanges endpoint.');
    assert.notOk(spySegmentChanges.called, 'On offline mode we should not call the segmentChanges endpoint.');
    assert.notOk(spyMySegments.called, 'On offline mode we should not call the mySegments endpoint.');
    assert.notOk(spyEventsBulk.called, 'On offline mode we should not call the events endpoint.');
    assert.notOk(spyTestImpressionsBulk.called, 'On offline mode we should not call the impressions endpoint.');
    assert.notOk(spyMetricsTimes.called, 'On offline mode we should not call the metric times endpoint.');
    assert.notOk(spyMetricsCounters.called, 'On offline mode we should not call the metric counters endpoint.');
    assert.notOk(spyAny.called, 'On offline mode we should NOT call to ANY endpoint, we are completely isolated from BE.');
  });
}

function DotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  client.track('a_key', 'a_tt', 'an_ev_id');
  client.track('another_key', 'another_tt', 'another_ev_id', 25);
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_2'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_2'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: 'on',
      testing_split2: 'off',
      testing_split3: 'custom_treatment',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('qa-user', ['testing_split', 'testing_split2', 'testing_split3', 'testing_not_exist']), {
      testing_split: {
        treatment: 'on',
        config: null
      },
      testing_split2: {
        treatment: 'off',
        config: null
      },
      testing_split3: {
        treatment: 'custom_treatment',
        config: null
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}

function DotYAMLTests(mockFileName, assert) {
  configMocks();
  var config = settingsGenerator(mockFileName);
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client(); // Tracking some events to test they are not flushed.

  assert.true(client.track('a_key', 'a_tt', 'an_ev_id'));
  assert.true(client.track('another_key', 'another_tt', 'another_ev_id', 25));
  assert.false(client.track('wasa', {}, [], 'invalid_stuff'));
  client.on(client.Event.SDK_READY, function () {
    assert.equal(client.getTreatment('qa-user', 'testing_split_on'), 'on');
    assert.equal(client.getTreatment('qa-user', 'testing_split_only_wl'), 'control');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_only_wl'), 'whitelisted');
    assert.equal(client.getTreatment('qa-user', 'testing_split_with_wl'), 'not_in_whitelist');
    assert.equal(client.getTreatment('key_for_wl', 'testing_split_with_wl'), 'one_key_wl');
    assert.equal(client.getTreatment('key_for_wl_1', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('key_for_wl_2', 'testing_split_with_wl'), 'multi_key_wl');
    assert.equal(client.getTreatment('qa-user', 'testing_split_off_with_config'), 'off');
    assert.equal(client.getTreatment('qa-user', 'not_existent'), 'control');
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_on'), {
      treatment: 'on',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_only_wl'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_only_wl'), {
      treatment: 'whitelisted',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_with_wl'), {
      treatment: 'not_in_whitelist',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl', 'testing_split_with_wl'), {
      treatment: 'one_key_wl',
      config: null
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_1', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('key_for_wl_2', 'testing_split_with_wl'), {
      treatment: 'multi_key_wl',
      config: '{"color": "brown"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'testing_split_off_with_config'), {
      treatment: 'off',
      config: '{"color": "green"}'
    });
    assert.deepEqual(client.getTreatmentWithConfig('qa-user', 'not_existent'), {
      treatment: 'control',
      config: null
    });
    assert.deepEqual(client.getTreatments('qa-user', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: 'on',
      testing_split_only_wl: 'control',
      testing_split_with_wl: 'not_in_whitelist',
      testing_split_off_with_config: 'off',
      testing_not_exist: 'control'
    });
    assert.deepEqual(client.getTreatmentsWithConfig('key_for_wl', ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config', 'testing_not_exist']), {
      testing_split_on: {
        treatment: 'on',
        config: null
      },
      testing_split_only_wl: {
        treatment: 'whitelisted',
        config: null
      },
      testing_split_with_wl: {
        treatment: 'one_key_wl',
        config: null
      },
      testing_split_off_with_config: {
        treatment: 'off',
        config: '{"color": "green"}'
      },
      testing_not_exist: {
        treatment: 'control',
        config: null
      }
    });
    networkAssertions(client, assert).then(function () {
      client.destroy().then(assert.end);
    });
  });
}

function ManagerDotSplitTests(assert) {
  configMocks();
  var config = settingsGenerator('.split');
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split', 'testing_split2', 'testing_split3']);
    var expectedView1 = {
      name: 'testing_split',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split2',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['off'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split3',
      changeNumber: 0,
      killed: false,
      trafficType: null,
      treatments: ['custom_treatment'],
      configs: {}
    };
    assert.deepEqual(manager.split('testing_split'), expectedView1);
    assert.deepEqual(manager.split('testing_split2'), expectedView2);
    assert.deepEqual(manager.split('testing_split3'), expectedView3);
    assert.equal(manager.split('split_not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3]);
    client.destroy().then(assert.end);
  });
}

function ManagerDotYamlTests(mockFileName, assert) {
  configMocks();
  var config = settingsGenerator(mockFileName);
  var factory = (0, _.SplitFactory)(config);
  var client = factory.client();
  var manager = factory.manager();
  manager.on(manager.Event.SDK_READY, function () {
    assert.deepEqual(manager.names(), ['testing_split_on', 'testing_split_only_wl', 'testing_split_with_wl', 'testing_split_off_with_config']);
    var expectedView1 = {
      name: 'testing_split_on',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['on'],
      configs: {}
    };
    var expectedView2 = {
      name: 'testing_split_only_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['whitelisted'],
      configs: {}
    };
    var expectedView3 = {
      name: 'testing_split_with_wl',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['not_in_whitelist', 'one_key_wl', 'multi_key_wl'],
      configs: {
        not_in_whitelist: '{"color": "green"}',
        multi_key_wl: '{"color": "brown"}'
      }
    };
    var expectedView4 = {
      name: 'testing_split_off_with_config',
      changeNumber: 0,
      killed: false,
      trafficType: 'localhost',
      treatments: ['off'],
      configs: {
        off: '{"color": "green"}'
      }
    };
    assert.deepEqual(manager.split('testing_split_on'), expectedView1);
    assert.deepEqual(manager.split('testing_split_only_wl'), expectedView2);
    assert.deepEqual(manager.split('testing_split_with_wl'), expectedView3);
    assert.deepEqual(manager.split('testing_split_off_with_config'), expectedView4);
    assert.equal(manager.split('not_existent'), null);
    assert.deepEqual(manager.splits(), [expectedView1, expectedView2, expectedView3, expectedView4]);
    client.destroy().then(assert.end);
  });
}